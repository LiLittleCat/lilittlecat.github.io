<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CentOS 7 上安装 MySQL 5.7</title>
    <url>/posts/f35f8af2/</url>
    <content><![CDATA[<img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/how-to-install-mysql-on-centos.png" height="200px">
<!-- <img data-src="images/images.jfif"/> -->
<!-- ![how-to-install-mysql-on-centos](https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/how-to-install-mysql-on-centos.png) -->
本文介绍了在 CentOS 7 上安装 MySQL 5.7 的过程，作为笔记方便以后查看。
<span id="more"></span>
## 开始安装

<p>卸载自带 mariadb 和已安装的 MySQL，如遇到依赖问题导致卸载出错则加上 <code>--nodeps</code> 参数：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 停止服务</span></span><br><span class="line">systemctl stop mysqld mariadb</span><br><span class="line">systemctl <span class="built_in">disable</span> mysqld mariadb</span><br><span class="line"><span class="comment"># 卸载已安装服务</span></span><br><span class="line">rpm -qa | grep mysql | xargs rpm -e</span><br><span class="line">rpm -qa | grep mariadb | xargs rpm -e --nodeps</span><br><span class="line"><span class="comment"># 删除相关文件</span></span><br><span class="line">rm -rvf /etc/my.cnf /var/lib/mysql /var/<span class="built_in">log</span>/mysqld.log</span><br><span class="line"><span class="comment"># 删除用户，非必须</span></span><br><span class="line">userdel -rf mysql</span><br></pre></td></tr></tbody></table></figure>

<h2 id="下载安装-MySQL"><a href="#下载安装-MySQL" class="headerlink" title="下载安装 MySQL"></a>下载安装 MySQL</h2><h3 id="网络畅通推荐使用-YUM"><a href="#网络畅通推荐使用-YUM" class="headerlink" title="网络畅通推荐使用 YUM"></a>网络畅通推荐使用 YUM</h3><p>下载 Repository：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">wget -c http://repo.mysql.com/mysql57-community-release-el7-10.noarch.rpm <span class="comment">#  -c 断点续传</span></span><br></pre></td></tr></tbody></table></figure>

<p>安装 Repository：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">yum -y install mysql57-community-release-el7-10.noarch.rpm</span><br></pre></td></tr></tbody></table></figure>

<p>安装服务器：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">yum -y install mysql-community-server</span><br></pre></td></tr></tbody></table></figure>

<h3 id="无网络先在有网络的地方下载安装包"><a href="#无网络先在有网络的地方下载安装包" class="headerlink" title="无网络先在有网络的地方下载安装包"></a>无网络先在有网络的地方下载安装包</h3><p>下载地址：<a href="https://downloads.mysql.com/archives/community/">https://downloads.mysql.com/archives/community/</a>，选择对应版本下载。</p>
<blockquote>
<p>推荐下载 mysql-5.7.30-1.el7.x86_64.rpm-bundle.tar</p>
</blockquote>
<p>解压下载的 tar 包，按如下顺序安装：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">rpm -ivh mysql-community-common-5.7.30-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-libs-5.7.30-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-client-5.7.30-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-server-5.7.30-1.el7.x86_64.rpm</span><br></pre></td></tr></tbody></table></figure>

<h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><p>启动服务：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">systemctl start mysqld</span><br></pre></td></tr></tbody></table></figure>

<p>设置开机启动：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> mysqld</span><br><span class="line">systemctl daemon-reload</span><br></pre></td></tr></tbody></table></figure>

<h2 id="修改登录密码"><a href="#修改登录密码" class="headerlink" title="修改登录密码"></a>修改登录密码</h2><p>查看安装完之后 root 用户的临时密码：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">grep <span class="string">"temporary password"</span> /var/<span class="built_in">log</span>/mysqld.log | awk -F <span class="string">" "</span> <span class="string">'{print $11}'</span> | awk <span class="string">'END{print}'</span></span><br></pre></td></tr></tbody></table></figure>

<p>登录 MySQL，第一次登录需要修改密码之后才能操作：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></tbody></table></figure>

<p>输入临时密码登录，然后修改用户密码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">mysql&gt; ALTER USER 'root'@'localhost' IDENTIFIED BY '你的密码';</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意：</p>
<p>MySQL 内置默认密码策略较严格，如需使用较简单的密码，先修改复杂密码之后方可修改密码策略。</p>
<p>查看密码策略：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE "%password%";</span><br></pre></td></tr></tbody></table></figure>

<p>修改密码长度，最短为 4，设置低于 4 仍然为 4：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">mysql&gt; SET GLOBAL validate_password_length=4;</span><br></pre></td></tr></tbody></table></figure>

<p>修改密码强度：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">mysql&gt; SET GLOBAL validate_password_policy=0;</span><br></pre></td></tr></tbody></table></figure>

<p>再通过上述 <code>ALTER USER</code> 修改较简单的密码。</p>
<p>此时为临时修改，永久修改需要修改 MySQL 配置文件 /etc/my.conf。</p>
<p>将以下内容添加到 /etc/my.conf 中：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">validate_password_policy=0</span><br><span class="line">validate_password_length=4</span><br></pre></td></tr></tbody></table></figure>

<p>重启服务即可：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">systemctl restart mysqld </span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p>刷新权限：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br></pre></td></tr></tbody></table></figure>

<p>允许远程登录：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '你的密码' WITH GRANT OPTION;</span><br></pre></td></tr></tbody></table></figure>

<p>退出：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">mysql&gt; exit</span><br></pre></td></tr></tbody></table></figure>

<h2 id="开放-3306-端口或者关闭防火墙"><a href="#开放-3306-端口或者关闭防火墙" class="headerlink" title="开放 3306 端口或者关闭防火墙"></a>开放 3306 端口或者关闭防火墙</h2><p>开放 3306 端口：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --add-port=3306/tcp</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>查看防火墙规则：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">firewall-cmd --list-all</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p>关闭防火墙：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></tbody></table></figure>

<p>取消防火墙开机自启：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line">systemctl daemon-reload</span><br></pre></td></tr></tbody></table></figure>

<h2 id="配置-MySQL-默认编码"><a href="#配置-MySQL-默认编码" class="headerlink" title="配置 MySQL 默认编码"></a>配置 MySQL 默认编码</h2><p>配置 MySQL 默认编码为 utf8，修改 MySQL 配置文件 /etc/my.conf。</p>
<p>将以下内容添加到 /etc/my.conf 中：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">character_set_server=utf8</span><br><span class="line">init_connect=<span class="string">'SET NAMES utf8'</span></span><br></pre></td></tr></tbody></table></figure>

<p>重启服务即可：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">systemctl restart mysqld </span><br></pre></td></tr></tbody></table></figure>

<p>登录 MySQL 查看是否修改成功：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">mysql&gt; show variables like '%character%';</span><br></pre></td></tr></tbody></table></figure>

<h2 id="安装完成"><a href="#安装完成" class="headerlink" title="安装完成"></a>安装完成</h2><p>完成上述步骤后就完成了 CentOS7 下 MySQL 5.7 Server 的安装，可使用 Navicat 等数据库管理软件连接。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>RPM 介绍及打包总结</title>
    <url>/posts/22fd6dd2/</url>
    <content><![CDATA[<img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/RPM_Logo.svg" height="200px">
RPM Package Manager (RPM) 是一个强大的命令行驱动的软件包管理工具，用来安装、卸载、校验、查询和更新 Linux 系统上的软件包。本文简单介绍了一下 RPM，并总结制作了 RPM 包的流程。

<span id="more"></span>

<h2 id="软件包管理系统和Linux发行版"><a href="#软件包管理系统和Linux发行版" class="headerlink" title="软件包管理系统和Linux发行版"></a>软件包管理系统和Linux发行版</h2><p>软件包管理系统：自动安装、配置、卸载和升级软件包的工具组合。</p>
<p>Linux 发行版中常见的有：</p>
<ul>
<li>RPM(Redhat Package Manager)</li>
<li>DPKG(Debian Package)</li>
</ul>
<p>使用他们的系统被分为两大派系:</p>
<ul>
<li>RedHat 系（CentOS、Fedora 等）</li>
<li>Debian 系（Ubuntu、Deepin 等）</li>
</ul>
<h2 id="RPM"><a href="#RPM" class="headerlink" title="RPM"></a>RPM</h2><p>一个 RPM 包包含了已经压缩的软件文件集和相关的软件内容信息，通常表现为以 <code>.rpm</code> 扩展名结尾的文件，如果是源代码包通常以 <code>src.rpm</code> 结尾。</p>
<h3 id="rpm-包命名"><a href="#rpm-包命名" class="headerlink" title="rpm 包命名"></a>rpm 包命名</h3><p>一般格式为：<code>name-version-release.arch.rpm</code>。</p>
<ul>
<li><code>name</code>：安装包的名称。</li>
<li><code>version</code>：版本信息。</li>
<li><code>release</code>：发行号、适应系统等。</li>
<li><code>arch</code>：适用的硬件平台。包括 <code>x86_64</code>、<code>i686</code> 等，<code>noarch</code> 表示能安装在任何平台。</li>
</ul>
<p>举例：</p>
<blockquote>
<p>nginx-1.16.1-1.el7.x86_64.rpm</p>
</blockquote>
<h3 id="rpm-命令"><a href="#rpm-命令" class="headerlink" title="rpm 命令"></a>rpm 命令</h3><p>安装管理 RPM 包需要用到 <code>rpm</code> 命令，常用参数如下：</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>-q</code></td>
<td align="center">查询 rpm 包的信息</td>
</tr>
<tr>
<td align="center"><code>-i</code></td>
<td align="center">安装 rpm 包</td>
</tr>
<tr>
<td align="center"><code>-U</code></td>
<td align="center">升级 rpm 包</td>
</tr>
<tr>
<td align="center"><code>-e</code></td>
<td align="center">卸载 rpm 包</td>
</tr>
<tr>
<td align="center"><code>-h</code></td>
<td align="center">以 <code>#</code> 显示安装进度</td>
</tr>
<tr>
<td align="center"><code>-v</code></td>
<td align="center">显示安装详情</td>
</tr>
<tr>
<td align="center"><code>-l</code></td>
<td align="center">列出安装包中文件</td>
</tr>
<tr>
<td align="center"><code>-p</code></td>
<td align="center">对 rpm 包进行查询、与其他参数一起使用</td>
</tr>
</tbody></table>
<p>以上参数需要组合使用，举例：</p>
<p>查看安装包信息</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">rpm -qip nginx-1.16.1-1.el7.x86_64.rpm</span><br></pre></td></tr></tbody></table></figure>

<p>列出安装包中的文件</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">rpm -qlp nginx-1.16.1-1.el7.x86_64.rpm</span><br></pre></td></tr></tbody></table></figure>

<p>安装安装包</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">rpm -ivh nginx-1.16.1-1.el7.x86_64.rpm</span><br></pre></td></tr></tbody></table></figure>

<p>查询已安装所有安装包</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">rpm -qa</span><br></pre></td></tr></tbody></table></figure>

<p>卸载安装包</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">rpm -evh nginx-1.16.1-1.el7.x86_64 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 后面跟 rpm 包的全名</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>补充：</p>
<ul>
<li>使用 <code>--nodeps</code> 跳过依赖验证，强制操作。</li>
<li>rpm默认不允许重复安装和降级安装，可使用 <code>--force</code> 强制安装。</li>
<li>可使用 <code>-qf</code> 查看某个文件属于哪个rpm包。</li>
</ul>
</blockquote>
<h2 id="YUM"><a href="#YUM" class="headerlink" title="YUM"></a>YUM</h2><p>当一个 rpm 包的安装需要依赖其他包时，就必须先安装依赖包。YUM（Yellowdog Updater, Modified）工具基于 RPM ，可以从指定源空间（服务器、本地目录等）自动下载 rpm 包并处理依赖关系。</p>
<h3 id="yum-命令"><a href="#yum-命令" class="headerlink" title="yum 命令"></a>yum 命令</h3><p>安装指定软件 :</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yum -y install nginx # -y 表示互动时输入 yes</span><br></pre></td></tr></tbody></table></figure>

<p>列出系统中已安装软件</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yum list</span><br></pre></td></tr></tbody></table></figure>

<p>列出系统中可升级的所有软件</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yum check-update</span><br></pre></td></tr></tbody></table></figure>

<p>升级系统中可升级的所有软件</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yum update</span><br></pre></td></tr></tbody></table></figure>

<p>升级指定软件</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yum update nginx</span><br></pre></td></tr></tbody></table></figure>

<p>卸载指定软件</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yum remove nginx</span><br></pre></td></tr></tbody></table></figure>

<h3 id="repo-文件"><a href="#repo-文件" class="headerlink" title="repo 文件"></a>repo 文件</h3><p>yum 使用仓库保存管理 rpm 包，仓库的配置文件以 <code>.repo</code> 为扩展名，存放在 <code>/etc/yum.repo.d/</code> 目录下。一个配置文件中包含了一个或多个 yum 仓库的配置信息。</p>
<h3 id="rpm-包下载"><a href="#rpm-包下载" class="headerlink" title="rpm 包下载"></a>rpm 包下载</h3><h4 id="使用-downloadonly"><a href="#使用-downloadonly" class="headerlink" title="使用 --downloadonly"></a>使用 <code>--downloadonly</code></h4><p>没有命令需要先安装 <code>downloadonly</code> 插件：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yum install yum-plugin-downloadonly</span><br></pre></td></tr></tbody></table></figure>

<p>下载 rpm 包和依赖：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yum install --downloadonly --downloaddir=/home/rpm-share/yum nginx</span><br></pre></td></tr></tbody></table></figure>

<p>默认下载路径：<code>/var/cache/yum/x86_64/[centos/fedora-version]/[repository]/packages</code></p>
<p>已安装再次下载：<code>reinstall</code>，此时不会下载依赖。</p>
<h4 id="使用-yumdownloader"><a href="#使用-yumdownloader" class="headerlink" title="使用 yumdownloader"></a>使用 yumdownloader</h4><p>没有命令需要先安装：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yum install -y yum-utils</span><br></pre></td></tr></tbody></table></figure>

<p>下载 rpm 包和依赖：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yumdownloader --destdir=/home/rpm-share/yum --resolve nginx</span><br></pre></td></tr></tbody></table></figure>

<p><code>--destdir</code> 指定下载的软件包存放路径，不指定默认当前路径。<br><code>--resolve</code> 解决依赖关系并下载所需的包。</p>
<h2 id="rpm-包制作"><a href="#rpm-包制作" class="headerlink" title="rpm 包制作"></a>rpm 包制作</h2><h3 id="spec-基础"><a href="#spec-基础" class="headerlink" title="spec 基础"></a>spec 基础</h3><p>要制作 rpm 包，关键在于编写包的 spec 描述文件。</p>
<h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><ul>
<li><p><code>Name</code>：软件包的名字，后面可使用 <code>%{name}</code> 的方式引用</p>
</li>
<li><p><code>Version</code>：软件版本号，后面可使用 <code>%{version}</code> 引用</p>
</li>
<li><p><code>Release</code>：软件包释出号/发行号，后面可使用 <code>%{release}</code> 引用</p>
</li>
<li><p><code>Group</code>：软件分组，参见 <code>/usr/share/doc/rpm-4.x.x/GROUPS</code></p>
</li>
<li><p><code>License</code>：软件授权方式，通常是 GPL（自由软件）或 GPLv2，BSD</p>
</li>
<li><p><code>Summary</code>：软件包的内容概要</p>
</li>
<li><p><code>URL</code>：软件的主页</p>
</li>
<li><p><code>Packager</code>：打包者的信息</p>
</li>
<li><p><code>Vendor</code>：软件开发者的名字，发行商或打包组织的信息，例如 <code>Fedora Project</code></p>
</li>
<li><p><code>Source0</code>：源代码包的名称，可以带多个用 <code>Source1</code>、<code>Source2</code> 等源，后面也可以用 <code>%{source1}</code>、<code>%{source2}</code> 引用，如有补丁也写在此处，如：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">Source0: %{name}-%{version}.tar.gz</span><br><span class="line">Patch0: some-bugs0.patch                    </span><br><span class="line">Patch1: some-bugs1.patch                   </span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>BuildRequires</code>: 制作过程中用到的软件包，构建依赖</p>
</li>
<li><p><code>Requires</code>: 安装时所需软件包</p>
<ul>
<li><code>Requires(pre/post/preun/postun)</code>: 指定不同阶段的依赖</li>
</ul>
</li>
<li><p><code>BuildRoot</code>: 这个是安装或编译时使用的「虚拟目录」，打包时会用到该目录下文件，可查看安装后文件路径，例如：<code>BuildRoot: %_topdir/BUILDROOT</code>。</p>
</li>
<li><p><code>%description</code>：软件包详细说明</p>
</li>
</ul>
<h4 id="主体"><a href="#主体" class="headerlink" title="主体"></a>主体</h4><p>主体包括 %prep，%build，%install，%files，%clean 几个关键阶段。</p>
<h5 id="prep-阶段"><a href="#prep-阶段" class="headerlink" title="%prep 阶段"></a>%prep 阶段</h5><p>对源代码包进行解压和打补丁，如：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">%prep</span><br><span class="line">%setup -q    <span class="comment"># 将 %sourcedir 目录下的源代码解压到 %builddir 目录下</span></span><br><span class="line">%pathch -p1  <span class="comment"># 给源代码打上补丁 Patch0 ， -p1 是忽略 patch 的第一层目录</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="build-阶段"><a href="#build-阶段" class="headerlink" title="%build 阶段"></a>%build 阶段</h5><p>在 <code>%_builddir</code> 目录下执行源码包的编译。一般是执行执行常见的 <code>configure</code> 和 <code>make</code> 操作，如：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">%configure											 <span class="comment"># 执行源代码的 configure 配置</span></span><br><span class="line">make %{?_smp_mflags} OPTIMIZE=<span class="string">"%{optflags}"</span>           <span class="comment"># 多核则并行编译</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="install-阶段"><a href="#install-阶段" class="headerlink" title="%install 阶段"></a>%install 阶段</h5><p>执行 <code>make install</code> 命令操作。开始把软件安装到虚拟的根目录中。这个阶段会在 <code>%buildrootdir</code> 目录里建好目录结构，然后将需要打包到 rpm 软件包里的文件从 <code>%builddir</code> 里拷贝到 <code>%_buildrootdir</code> 里对应的目录里。</p>
<p>在 <code>~/rpmbuild/BUILD/%{name}-%{version}</code> 目录中进行 <code>make install</code> 的操作。<code>%install</code> 很重要，因为如果这里的路径不对的话，则下面 <code>%file</code> 中寻找文件的时候就会失败。</p>
<blockquote>
<p>注意：<br><code>%install</code> 部分使用的是绝对路径，而 <code>%file</code> 部分使用则是相对路径。<br>当用户最终用 <code>rpm -ivh</code> 安装软件包时，这些文件会安装到用户系统中相应的目录里。</p>
</blockquote>
<p>如：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">%install</span><br><span class="line">rm -rf <span class="variable">$RPM_BUILD_ROOT</span> 						<span class="comment"># 清空下安装目录，实际会自动清除</span></span><br><span class="line">make install DESTDIR=<span class="variable">$RPM_BUILD_ROOT</span> 		<span class="comment"># 安装到 buildroot 目录下         </span></span><br></pre></td></tr></tbody></table></figure>

<p><code>%install</code> 阶段还可以执行相关脚本</p>
<ul>
<li><code>%pre</code> 安装前执行的脚本</li>
<li><code>%post</code> 安装后执行的脚本</li>
<li><code>%preun</code> 卸载前执行的脚本</li>
<li><code>%postun</code> 卸载后执行的脚本</li>
</ul>
<blockquote>
<p>注意：<br><code>%preun</code> 在升级的时候会执行，<code>%postun</code> 在升级的时候不会执行。</p>
</blockquote>
<h5 id="file-阶段"><a href="#file-阶段" class="headerlink" title="%file 阶段"></a>%file 阶段</h5><p>说明会将 <code>%{buildroot}</code> 目录下的哪些文件和目录最终打包到rpm包里。</p>
<p>定义软件包所包含的文件，分为三类：</p>
<ul>
<li>说明文档（doc）</li>
<li>配置文件（config）</li>
<li>执行程序</li>
</ul>
<p>在 <code>%files</code> 阶段的第一条命令的语法是：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">%defattr(文件权限,用户名,组名,目录权限) </span><br></pre></td></tr></tbody></table></figure>

<p>还可定义文件存取权限，拥有者及组别。如：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">%files</span><br><span class="line">%defattr (-,root,root,0755)                     <span class="comment"># 设定默认权限</span></span><br><span class="line">%config(noreplace) /etc/my.cnf                  <span class="comment"># 表明是配置文件，noplace 表示替换文件</span></span><br><span class="line">%doc %{_mandir}/1.log                           <span class="comment"># 表明这个是文档</span></span><br><span class="line">%attr(755, root, root) %{_sbindir}/mysqld	    <span class="comment"># 分别是权限，用户，用户组</span></span><br><span class="line">%exclude %{_mandir}/2.log					  <span class="comment"># 列出不想打包到 rpm 中的文件</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意：</p>
<ul>
<li><code>%files</code> 里的文件同时需要在 <code>%install</code> 中安装。</li>
<li><code>%{buildroot}</code> 里的所有文件都要明确被指定是否要被打包到 rpm 里。</li>
<li>如果声明了 <code>%{buildroot}</code> 里不存在的文件或者目录也会报错。</li>
<li><code>%exclude</code> 指定的文件如果不存在会报错。</li>
</ul>
</blockquote>
<h5 id="clean-阶段"><a href="#clean-阶段" class="headerlink" title="%clean 阶段"></a>%clean 阶段</h5><p>编译完成后一些清理工作，主要包括对 <code>%{buildroot}</code> 目录的清空（非必须），如：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">make clean</span><br></pre></td></tr></tbody></table></figure>

<h5 id="changelog-阶段"><a href="#changelog-阶段" class="headerlink" title="%changelog 阶段"></a>%changelog 阶段</h5><p>主要记录的每次打包时的修改变更日志。标准格式是：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">* date +<span class="string">"%a %b %d %Y"</span> 修改人 邮箱 本次版本 x.y.z-p </span><br><span class="line">- 本次变更修改了那些内容</span><br></pre></td></tr></tbody></table></figure>

<h4 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h4><h5 id="内建宏"><a href="#内建宏" class="headerlink" title="内建宏"></a>内建宏</h5><p>spec 文件中在定义文件的安装路径时通常会使用 RPM 内建的宏定义，可以在 <code>/usr/lib/rpm/macros</code> 找到，附录一些常见的宏：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">%{_sysconfdir}        /etc</span><br><span class="line">%{_prefix}            /usr</span><br><span class="line">%{_exec_prefix}       %{_prefix}</span><br><span class="line">%{_bindir}            %{_exec_prefix}/bin</span><br><span class="line">%{_lib}               lib (lib64 on 64bit systems)</span><br><span class="line">%{_libdir}            %{_exec_prefix}/%{_lib}</span><br><span class="line">%{_libexecdir}        %{_exec_prefix}/libexec</span><br><span class="line">%{_sbindir}           %{_exec_prefix}/sbin</span><br><span class="line">%{_sharedstatedir}    /var/lib</span><br><span class="line">%{_datadir}           %{_prefix}/share</span><br><span class="line">%{_includedir}        %{_prefix}/include</span><br><span class="line">%{_oldincludedir}     /usr/include</span><br><span class="line">%{_infodir}           /usr/share/info</span><br><span class="line">%{_mandir}            /usr/share/man</span><br><span class="line">%{_localstatedir}     /var</span><br><span class="line">%{_initddir}          %{_sysconfdir}/rc.d/init.d </span><br><span class="line">%{_topdir}            %{getenv:HOME}/rpmbuild</span><br><span class="line">%{_builddir}          %{_topdir}/BUILD</span><br><span class="line">%{_rpmdir}            %{_topdir}/RPMS</span><br><span class="line">%{_sourcedir}         %{_topdir}/SOURCES</span><br><span class="line">%{_specdir}           %{_topdir}/SPECS</span><br><span class="line">%{_srcrpmdir}         %{_topdir}/SRPMS</span><br><span class="line">%{_buildrootdir}      %{_topdir}/BUILDROOT</span><br><span class="line">%{_var}               /var</span><br><span class="line">%{_tmppath}           %{_var}/tmp</span><br><span class="line">%{_usr}               /usr</span><br><span class="line">%{_usrsrc}            %{_usr}/src</span><br><span class="line">%{_docdir}            %{_datadir}/doc</span><br><span class="line">%{buildroot}          %{_buildrootdir}/%{name}-%{version}-%{release}.%{_arch}</span><br><span class="line">$RPM_BUILD_ROOT       %{buildroot}</span><br></pre></td></tr></tbody></table></figure>

<p>通过命令 <code>rpm --eval "%{宏名称}"</code> 来查看具体对应路径，如：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">rpm --<span class="built_in">eval</span> <span class="string">"%{_topdir}"</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="自定义宏"><a href="#自定义宏" class="headerlink" title="自定义宏"></a>自定义宏</h5><p>使用 <code>%define</code> 可自定义宏变量。</p>
<blockquote>
<p>注意：<br>打包时会对所有安装的文件进行 <code>strip</code> 操作，去除调试信息等。<code>strip</code> 操作定义在宏 <code>__os_install_post</code> 中，可通过 <code>rpmbuild --showrc</code> 查看，将其设为 <code>%{nil}</code> 可跳过 <code>strip</code> 操作。即：<code>%define __os_install_post %{nil}</code></p>
</blockquote>
<h3 id="rpmbuild-打包"><a href="#rpmbuild-打包" class="headerlink" title="rpmbuild 打包"></a>rpmbuild 打包</h3><p>使用 <code>rpmbuild</code> 制作rpm包，<code>rpmbuid</code> 的默认工作路径是 <code>$HOME/rpmbuild</code>，并且推荐用户在制作 rpm 软件包时尽量不要以 root 身份进行操作。</p>
<h4 id="打包目录"><a href="#打包目录" class="headerlink" title="打包目录"></a>打包目录</h4><p>构建打包目录，一般在 <code>~/rpmbuild</code> 目录下建立以下目录：</p>
<ul>
<li><code>SPEC</code></li>
<li><code>SOURCE</code> </li>
<li><code>BUILD</code></li>
<li><code>RPM</code></li>
<li><code>SRPM</code></li>
<li><code>BUILDROOT</code></li>
</ul>
<p>对应关系：</p>
<table>
<thead>
<tr>
<th>默认位置</th>
<th>宏</th>
<th>名称</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>~/rpmbuild/SPECS</td>
<td>%_specdir</td>
<td>spec 文件目录</td>
<td>保存 RPM 包配置（.spec）文件</td>
</tr>
<tr>
<td>~/rpmbuild/SOURCES</td>
<td>%_sourcedir</td>
<td>源代码目录</td>
<td>保存源码包（如 .tar 包）和所有 patch 补丁</td>
</tr>
<tr>
<td>~/rpmbuild/BUILD</td>
<td>%_builddir</td>
<td>构建目录</td>
<td>源码包被解压至此，并在该目录的子目录完成编译</td>
</tr>
<tr>
<td>~/rpmbuild/RPMS</td>
<td>%_rpmdir</td>
<td>标准 RPM 包目录</td>
<td>生成/保存二进制 RPM 包</td>
</tr>
<tr>
<td>~/rpmbuild/SRPMS</td>
<td>%_srcrpmdir</td>
<td>源代码 RPM 包目录</td>
<td>生成/保存源码 RPM 包（SRPM）</td>
</tr>
<tr>
<td>~/rpmbuild/BUILDROOT</td>
<td>%_buildrootdir</td>
<td>最终安装目录</td>
<td>保存 <code>%install</code> 阶段安装的文件</td>
</tr>
</tbody></table>
<h4 id="打包命令"><a href="#打包命令" class="headerlink" title="打包命令"></a>打包命令</h4><p>切换到 <code>rpmbuild/SPECS</code> 目录下执行打包编译命令，如：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">rpmbuild -ba 软件名-版本.spec </span><br></pre></td></tr></tbody></table></figure>

<p><code>rpmbuild</code>命令参数：</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>-bp</code></td>
<td align="center">只解压源码及应用补丁</td>
</tr>
<tr>
<td align="center"><code>-bc</code></td>
<td align="center">只进行编译</td>
</tr>
<tr>
<td align="center"><code>-bi</code></td>
<td align="center">只进行安装到 <code>%{buildroot}</code></td>
</tr>
<tr>
<td align="center"><code>-bb</code></td>
<td align="center">只生成二进制 rpm 包</td>
</tr>
<tr>
<td align="center"><code>-bs</code></td>
<td align="center">只生成源码 rpm 包</td>
</tr>
<tr>
<td align="center"><code>-ba</code></td>
<td align="center">生成二进制 rpm 包和源码 rpm 包</td>
</tr>
<tr>
<td align="center"><code>--target</code></td>
<td align="center">指定生成 rpm 包的平台</td>
</tr>
</tbody></table>
<h4 id="修改默认工作路径"><a href="#修改默认工作路径" class="headerlink" title="修改默认工作路径"></a>修改默认工作路径</h4><p><code>rpmbuild</code> 默认工作路径通常由 <code>%_topdir</code> 的宏变量来定义。如果想更改有以下方法：</p>
<h5 id="修改-rpmmacros-的隐藏文件"><a href="#修改-rpmmacros-的隐藏文件" class="headerlink" title="修改 .rpmmacros 的隐藏文件"></a>修改 <code>.rpmmacros</code> 的隐藏文件</h5><p>在 <code>root</code> 下建立一个名为 <code>.rpmmacros</code> 的隐藏文件，然后在里面重新定义 <code>%_topdir</code>，指向一个新的目录名。<code>.rpmmacros</code> 文件内容如下：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">%_topdir %(<span class="built_in">echo</span> <span class="variable">$HOME</span>)/rpmbuild</span><br><span class="line"></span><br><span class="line">%_smp_mflags %( \</span><br><span class="line">    [ -z <span class="string">"<span class="variable">$RPM_BUILD_NCPUS</span>"</span> ] \\\</span><br><span class="line">        &amp;&amp; RPM_BUILD_NCPUS=<span class="string">"`/usr/bin/nproc 2&gt;/dev/null || \\\</span></span><br><span class="line"><span class="string">                             /usr/bin/getconf _NPROCESSORS_ONLN`"</span>; \\\</span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$RPM_BUILD_NCPUS</span>"</span> -gt 16 ]; <span class="keyword">then</span> \\\</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"-j16"</span>; \\\</span><br><span class="line">    <span class="keyword">elif</span> [ <span class="string">"<span class="variable">$RPM_BUILD_NCPUS</span>"</span> -gt 3 ]; <span class="keyword">then</span> \\\</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"-j<span class="variable">$RPM_BUILD_NCPUS</span>"</span>; \\\</span><br><span class="line">    <span class="keyword">else</span> \\\</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"-j3"</span>; \\\</span><br><span class="line">    <span class="keyword">fi</span> )</span><br><span class="line">    </span><br><span class="line">%__arch_install_post \</span><br><span class="line">    [ <span class="string">"%{buildarch}"</span> = <span class="string">"noarch"</span> ] || QA_CHECK_RPATHS=1 ; \</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"<span class="variable">${QA_CHECK_RPATHS:-}</span>"</span> <span class="keyword">in</span> [1yY]*) /usr/lib/rpm/check-rpaths ;; <span class="keyword">esac</span> \</span><br><span class="line">    /usr/lib/rpm/check-buildroot</span><br></pre></td></tr></tbody></table></figure>

<h5 id="使用-rpmbuild-命令时定义"><a href="#使用-rpmbuild-命令时定义" class="headerlink" title="使用 rpmbuild 命令时定义"></a>使用 <code>rpmbuild</code> 命令时定义</h5><p>使用 <code>rpmbuild</code> 时覆盖 <code>%_topdir</code> 的宏变量定义来指定此次打包的工作路径：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">rpmbuild --define <span class="string">"_topdir <span class="variable">${dir:-新的目录}</span>"</span> -ba 软件名-版本.spec </span><br></pre></td></tr></tbody></table></figure>

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>RPM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 容器 - 概述</title>
    <url>/posts/81a892b9/</url>
    <content><![CDATA[<img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/logo-java-text-color.svg" height="200px">

<p>本系列旨在归纳总结 Java 容器相关类的知识，并深入分析常用容器类的源代码。本文简单描述了 Java 容器相关概念。</p>
<span id="more"></span>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一个程序在运行过程中会根据某些条件创建多个对象，这些条件和创建对象的个数在运行之前都是未知的。为此，Java 提供了多种方式来保存对象（对象的引用）。比如数组，但是数组的大小在创建时就已固定，不适合复杂的持有对象的场景。除此之外，Java 类库中还提供了一套容器类来解决这个问题。</p>
<p>其中基本的类型是 <strong>List</strong>、<strong>Set</strong>、<strong>Queue</strong> 和 <strong>Map</strong>，这些对象类型也称为<em>集合类</em>，但由于 Java 类库中使用了 <strong>Collection</strong> 这个名词指代某一对象，所以把这些用来保存对象的类统称为“容器”。</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p>JDK 8 中 Collection 和 Map 的类图如下所示：<br><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/Collection.svg" alt="Collection"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/Map.svg" alt="Map"></p>
<p>其中单独列出的接口和类：</p>
<ul>
<li><p>Comparator</p>
<p>比较器接口，是一个函数式接口，可通过实现其方法 <code>compare()</code> 对容器中的元素进行排序。</p>
</li>
<li><p>RandomAccess</p>
<p>是一个空接口，标识一个 <code>List</code> 是否支持快速随机访问，一个 List 支持快速随机访问时，使用 for 循环遍历比采用 Iterator 迭代器遍历更快速。实现类：<code>ArrayList</code>，<code>AttributeList</code>，<code>CopyOnWriteArrayList</code>，<code>RoleList</code>，<code>RoleUnresolvedList</code>，<code>Stack</code>，<code>Vector</code>。</p>
</li>
<li><p>Iterator 和 ListIterator</p>
<p><code>Iterator</code> 接口使用了迭代器设计模式来对所有的容器进行快速遍历，容器本身不需要关注存储元素的数据类型，这些确定类型和转型的工作由 <code>Iterator</code> 负责实现。<code>Iterator</code> 只支持<code>hasNext()</code>、<code>next()</code>、<code>remove()</code> 三种操作，而 <code>ListIterator</code> 是 List 容器所独有的迭代器，与 <code>Iterator</code> 相比，<code>ListIterator</code> 还包含 <code>add()</code>、<code>hasPrevious()</code>、<code>previous()</code>、<code>nextIndex()</code>、<code>previousIndex()</code>、<code>set()</code>  等方法，能够在遍历过程中修改集合、逆向顺序遍历、定位遍历索引；而 <code>Iterator</code> 只能遍历不能修改、只能顺向顺序遍历、不能定位索引。</p>
</li>
<li><p>Iterable</p>
<p>允许实现此接口的对象使用 <code>for-each loop</code>。<code>Iterable</code> 接口的实现又依赖于实现了 <code>Iterator</code> 的内部类(参照 <code>LinkedList</code> 中 <code>listIterator()</code> 和 <code>descendingIterator()</code> 的 JDK 源码)。有的容器类会有多个实现 <code>Iterator</code> 接口的内部类，通过返回不同的迭代器实现不同的迭代方式。</p>
</li>
<li><p>Arrays 和 Collections</p>
<p><code>Arrays</code> 是关于数组的封装类，封装了对数组操作的多种方法，如 <code>sort()</code>、<code>copyOf()</code>、<code>binarySearch()</code>、<code>asList()</code> 等方法；<code>Collections</code> 封装了很多对于容器的操作，如 <code>max()</code>、<code>min()</code>、<code>reverse()</code>、<code>sort()</code> 等方法，生成同步容器如 <code>Collections.synchronizedList()</code>、<code>Collections.synchronizedSet()</code> 等。</p>
</li>
</ul>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set 的值是不可重复的，无序的，最多只有一个 <code>null</code> 值。</p>
<p>其子容器主要包括：</p>
<ul>
<li>AbstractSet：抽象集合类，实现了 <code>equals()</code> 和 <code>hashCode()</code> 方法</li>
<li>SortedSet：有序（默认自然序）</li>
<li>NavigableSet：继承自 <code>SortedSet</code></li>
<li>TreeSet：实现 <code>NavigableSet</code> 接口，继承 <code>AbstractSet</code></li>
<li>HashSet：hash 方式存储（实际上是一个 Map 的实例）</li>
<li>LinkedHashSet：双向循环链表，不可重复，顺序与插入顺序保持一致，或者实现自定义的顺序</li>
<li>EmumSet：只能存放 <code>Emum</code> 枚举类型</li>
</ul>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List 的值是可重复的、无序的、可添加 <code>null</code> 值。</p>
<p>List 子容器主要包括：</p>
<ul>
<li>ArrayList：数组实现，随机存取</li>
<li>LinkedList：双向循环链表，顺序存取</li>
<li>Vector：同步，其他与 <code>ArrayList</code> 相同</li>
<li>Stack：同步，继承自 <code>Vector</code>，“先进后出”</li>
</ul>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>Queue 实现了数据结构中的队列，具有“先进先出”的特点。</p>
<p>主要的子容器包括：</p>
<ul>
<li>AbstractQueue：抽象队列</li>
<li>PriorityQueue：继承自 <code>AbstractQueue</code>，数据结构中堆 Heap 的实现</li>
<li>Deque：双端队列，两端都可以插入和删除 <ul>
<li>输出受限的双端队列 </li>
<li>输入受限的双端队列 </li>
</ul>
</li>
</ul>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map 容器是利用映射关系来存储键值对的，独立于 <code>List</code>、<code>Set</code>、<code>Queue</code>。键值对是一一对应的关系，一般允许键值为空，不可重复，是完全抽象类 <code>Dictionary</code> 的接口版本。</p>
<p>Map的子容器主要包括：</p>
<ul>
<li>AbstractMap：实现了内部 <code>EntrySet</code> 接口，实现 <code>equals()</code>、<code>hashCode()</code> 方法</li>
<li>SortedMap：有序（默认自然序）</li>
<li>NavigableMap：继承自 <code>SortMap</code></li>
<li>TreeMap：基于红黑树，实现 <code>NavigableMap</code> 接口，继承 <code>Abstractmap</code></li>
<li>HashMap：非同步，允许 <code>null</code></li>
<li>LinkedHashMap：非同步，允许 <code>null</code>，双向循环链表，顺序与插入顺序一致（类比于 <code>LinkedHashSet</code> ），或者实现自定义顺序。</li>
<li>HashTable：同步，不允许 <code>null</code></li>
<li>EmumMap：只能存放 <code>Emum</code> 枚举类型</li>
<li>WeakHashMap：弱键（weak key）映射，允许释放映射所指向的对象，为解决某类特殊问题而设计。如果映射之外没有应用指向某个“键”，则该“键”可以被 GC 回收</li>
<li>IdentityHashMap：使用“==”代替 <code>equals()</code> 对键进行比较的散列映射，专门为解决特殊问题而设计</li>
<li>ConcurrentHashMap：线程安全的 <code>Map</code>，属于 <code>java.util.concurrent</code> 并发包中</li>
</ul>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/WZD2012/article/details/73245493?utm_source=blogxgwz5">https://blog.csdn.net/WZD2012/article/details/73245493?utm_source=blogxgwz5</a></p>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Java 集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/4a17b156/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>设计模式中的设计原则</title>
    <url>/posts/826d12e5/</url>
    <content><![CDATA[<h2 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h2><ul>
<li>抽象</li>
<li>封装</li>
<li>继承</li>
<li>多态</li>
</ul>
<h2 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h2><blockquote>
<p><a href="http://c.biancheng.net/design_pattern/">设计模式（Design Pattern）</a>是前辈们对代码开发经验的总结，是解决特定问题的一系列套路。它不是语法规定，而是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案。</p>
<p>1995 年，GoF（Gang of Four，四人组/四人帮）合作出版了《设计模式：可复用面向对象软件的基础》一书，共收录了 23 种设计模式，从此树立了软件设计模式领域的里程碑，人称「GoF设计模式」。</p>
</blockquote>
<h2 id="为什么学习设计模式"><a href="#为什么学习设计模式" class="headerlink" title="为什么学习设计模式"></a>为什么学习设计模式</h2><ul>
<li><p>设计模式是经过实践验证的解决方案，能指导你如何使用面向对象的设计原则来解决各种问题。 </p>
</li>
<li><p>设计模式是高效沟通的通用语言。你只需说“这里用单例就可以了”，所有人都会理解这条建议背后的想法。只要知晓模式及其名称，你就无需解释什么是单例。</p>
</li>
<li><p>…</p>
</li>
</ul>
<h2 id="优秀设计的特征"><a href="#优秀设计的特征" class="headerlink" title="优秀设计的特征"></a>优秀设计的特征</h2><ul>
<li><p><strong>代码复用</strong></p>
<p>减少开发成本的最常用的方式之一。</p>
</li>
<li><p><strong>扩展性</strong></p>
<p>理解更深入之后重构代码；程序经常需要变化适应新需求。</p>
</li>
</ul>
<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><h3 id="封装变化的内容"><a href="#封装变化的内容" class="headerlink" title="封装变化的内容"></a>封装变化的内容</h3><p>找到程序中的变化内容并将其与不变的内容区分开，将变更的影响最小化。</p>
<h4 id="方法层面的封装"><a href="#方法层面的封装" class="headerlink" title="方法层面的封装"></a>方法层面的封装</h4><p>例如，有一个获取订单总价的方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">method <span class="title">getOrderTotal</span><span class="params">(order)</span></span></span><br><span class="line"><span class="function">	total </span>= <span class="number">0</span></span><br><span class="line">	foreach item in order.lineItems</span><br><span class="line">		total += item.price * item.<span class="function">quantity</span></span><br><span class="line"><span class="function">   </span></span><br><span class="line"><span class="function">	<span class="title">if</span> <span class="params">(order.country == <span class="string">"US"</span>)</span></span></span><br><span class="line"><span class="function">         <span class="comment">// 美国增值税</span></span></span><br><span class="line"><span class="function">		total +</span>= total * <span class="number">0.07</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (order.country == <span class="string">"EU"</span>)</span><br><span class="line">		<span class="comment">// 欧洲增值税</span></span><br><span class="line">		total += total * <span class="number">0.20</span></span><br><span class="line">	<span class="keyword">return</span> total</span><br></pre></td></tr></tbody></table></figure>

<p><strong>修改前：</strong>税率计算代码和方法的其他代码混杂在一起。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">method <span class="title">getOrderTotal</span><span class="params">(order)</span></span></span><br><span class="line"><span class="function">	total </span>= <span class="number">0</span></span><br><span class="line">	foreach item in order.lineItems</span><br><span class="line">		total += item.price * item.quantity</span><br><span class="line"></span><br><span class="line">	total += total * getTaxRate(order.country)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="function">total</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">method <span class="title">getTaxRate</span><span class="params">(country)</span></span></span><br><span class="line"><span class="function">	<span class="title">if</span> <span class="params">(country == <span class="string">"US"</span>)</span></span></span><br><span class="line"><span class="function">        <span class="comment">// 美国增值税</span></span></span><br><span class="line"><span class="function">		return 0.07 </span></span><br><span class="line"><span class="function">	<span class="keyword">else</span> <span class="title">if</span> <span class="params">(country == <span class="string">"EU"</span>)</span></span></span><br><span class="line"><span class="function">        <span class="comment">// 欧洲增值税</span></span></span><br><span class="line"><span class="function">		return 0.20 </span></span><br><span class="line"><span class="function">	<span class="keyword">else</span></span></span><br><span class="line"><span class="function">		return 0</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>修改后：</strong>可通过调用指定方法获取税率。</p>
<h4 id="类层面的封装"><a href="#类层面的封装" class="headerlink" title="类层面的封装"></a>类层面的封装</h4><p>如果方法中的职责越来越多，还有其他变量引入，则可以将这些东西抽取到一个新类中。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/image-20210127212601157.png"></p>
<p><strong>修改前：</strong>在 订单 Order 类中计算税金。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/image-20210127212653972.png"></p>
<p><strong>修改后：</strong>对订单类隐藏税金计算。</p>
<h3 id="面向接口开发，而不是面向实现"><a href="#面向接口开发，而不是面向实现" class="headerlink" title="面向接口开发，而不是面向实现"></a>面向接口开发，而不是面向实现</h3><p>面向接口进行开发，而不是面向实现；依赖于抽象类型，而不是具体类。</p>
<p>例如，<code>Company</code> 类中有一个开发软件方法：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/image-20210127213442466.png"></p>
<p><strong>修改前：</strong>所有类都紧密耦合。</p>
<p>归纳雇员的方法并抽取通用接口：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/image-20210127235721308.png"></p>
<p><strong>优化：</strong>多态机制能帮助我们简化代码，但 <code>Company</code> 类的其他部分仍然依赖于具体的雇员类。</p>
<p>再抽象一个该方法来获取雇员：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/image-20210127213849586.png"></p>
<p><strong>修改后：</strong> <code>Company</code> 类的主要方法独立于具体的雇员类。雇员对象将在具体公司子类中创建。（工厂方法模式）</p>
<h3 id="组合优于继承"><a href="#组合优于继承" class="headerlink" title="组合优于继承"></a>组合优于继承</h3><p>继承可能是类之间最明显、最简单的代码复用方式。</p>
<p>继承存在的问题：</p>
<ul>
<li>子类不能减少父类的接口。（必须实现父类所有抽象方法）</li>
<li>重写方法时需要保证与父类版本兼容。（子类对象可能传递给父类作为参数的方法）</li>
<li>继承打破了父类的封装。（子类可以访问父类内部详细内容）</li>
<li>子类与父类紧密耦合。（父类修改可能破坏子类功能）</li>
<li>通过继承复用代码可能导致平行继承体系的产生。（多维度继承）</li>
</ul>
<p>例如，有一个创建车的程序，需要创建卡车和小汽车，有电车和油车之分，还有自动驾驶和手动驾驶之分：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/image-20210127214814494.png"></p>
<p><strong>继承：</strong>在多个维度上扩展一个类（汽车类型 × 引擎类型 × 驾驶类型）可能会导致子类组合的数量爆炸。</p>
<p>使用组合，将汽车行为委派给别的对象：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/image-20210127215038889.png"></p>
<p><strong>组合：</strong>将不同“维度”的功能抽取到各自的类层次结构中。（策略模式）</p>
<h3 id="SOLID-原则"><a href="#SOLID-原则" class="headerlink" title="SOLID 原则"></a>SOLID 原则</h3><p>Robert C. Martin《敏捷软件开发：原则、模式与实践》中首次提出。SOLID 是让软件设计更易于理解、更加灵活和更易于维护的五个原则的简称。</p>
<h4 id="单一职责原则-Single-Responsibility-Principle"><a href="#单一职责原则-Single-Responsibility-Principle" class="headerlink" title="单一职责原则(Single Responsibility Principle)"></a>单一职责原则(Single Responsibility Principle)</h4><p>修改类的原因只能有一个。该原则的目的是减少复杂度，尽量让每个类只负责软件中的一个功能，并将该功能完全封装（隐藏）在该类中。</p>
<p>例如，有一个雇员类：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/image-20210127215722067.png"></p>
<p><strong>修改前：</strong>类中包含多个不同的行为。</p>
<p>将与打印时间表报告相关的行为移动到一个单独的类中，这样其他与报告相关的内容也可以移到这个类中。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/image-20210127215854115.png"></p>
<p><strong>修改后：</strong>额外行为有了它们自己的类。</p>
<h4 id="开闭原则-Open-closed-Principle"><a href="#开闭原则-Open-closed-Principle" class="headerlink" title="开闭原则(Open/closed Principle)"></a>开闭原则(Open/closed Principle)</h4><p>对于扩展，类应该是“开放”的；对于修改，类则应是“封闭”的。该原则主要理念是实现新功能时保持已有代码不变。</p>
<p>例如，有一个计算运输费用的 <code>Order</code> 类，该类中所有运输方法都以硬编码的方式实现。如果你需要添加一个新的运输方式，那就必须承担可能对 <code>Order</code> 类造成破坏的风险来对其进行修改。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/image-20210127235833617.png"></p>
<p><strong>修改前：</strong>在程序中添加新的运输方式时，你必须对 <code>Order</code> 类进行修改。</p>
<p>使用策略模式进行修改，将运输方法抽取出来：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/image-20210127235902200.png"></p>
<p><strong>修改后：</strong>添加新的运输方式不需要修改已有的类，并且满足单一职责原则。</p>
<h4 id="里氏替换原则-Liskov-Substitution-Principle"><a href="#里氏替换原则-Liskov-Substitution-Principle" class="headerlink" title="里氏替换原则(Liskov Substitution Principle)"></a>里氏替换原则(Liskov Substitution Principle)</h4><p>当你扩展一个类时， 要能在不修改客户端（使用这个类的地方）代码的情况下将子类的对象作为父类对象进行传递。</p>
<p>该原则对子类的具体要求：</p>
<ul>
<li><p>子类方法的参数类型必须与其父类的参数类型相匹配或更加抽象。</p>
<p>父类有方法 <code>feed(Cat c)</code>，子类重写 <code>feed(Animal c)</code> ✔️​ <code>feed(BlackCat c)</code> ❌</p>
</li>
<li><p>子类方法的返回值类型必须与父类方法的返回值类型或是其子类相匹配。</p>
<p>父类有方法 <code>Cat buyCat()</code>，子类重写 <code>BlackCat buyCat()</code> ✔️​ <code>Animal buyCat()</code> ❌</p>
</li>
<li><p>子类中的方法不应抛出基础方法预期之外的异常类型。</p>
</li>
<li><p>子类不应该加强其前置条件。</p>
<p>父类方法参数为 <code>int</code>，子类方法参数为 <code>正数</code>❌</p>
</li>
<li><p>子类不能削弱其后置条件。</p>
<p>父类方法使用数据库连接并关闭，子类方法不关闭连接❌</p>
</li>
<li><p>父类的不变量必须保留。</p>
</li>
<li><p>子类不能修改超类中私有成员变量的值。</p>
</li>
</ul>
<p>例如，有一个文档类：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/image-20210128002500134.png"></p>
<p><strong>修改前：</strong>只读文件中的保存行为没有任何意义，因此子类试图在重写后的方法中重置父类行为来解决这个问题。</p>
<p>只读文件子类（<code>ReadOnlyDocument</code>）中的 <code>save</code> 方法会在被调用时抛出一个异常，而父类方法则没有这个限制。如果在保存前没有检查文档类型，客户端代码将会出错。</p>
<p>重新设计类层次结构，子类应该扩展超类的行为：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/image-20210128003300671.png"></p>
<p><strong>修改后：</strong>当把只读文档类作为层次结构中的基类后，这个问题得到了解决。只读文档变成了层次结构中的基类。可写文件现在变成了子类，对基类进行扩展并添加了保存行为。</p>
<h4 id="接口隔离原则-Interface-Segregation-Principle"><a href="#接口隔离原则-Interface-Segregation-Principle" class="headerlink" title="接口隔离原则(Interface Segregation Principle)"></a>接口隔离原则(Interface Segregation Principle)</h4><p>客户端不应被强迫依赖于其不使用的方法。尽量缩小接口的范围，使得客户端的类不必实现其不需要的行为。</p>
<p>例如，有一程序库可以和云服务供应商整合：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/image-20210128000002165.png"></p>
<p><strong>修改前：</strong>不是所有客户端能满足复杂接口的要求。</p>
<p>将接口拆分为多个部分：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/image-20210128000032581.png"></p>
<p><strong>修改后：</strong>一个复杂的接口被拆分为一组颗粒度更小的接口。</p>
<p>不要进一步划分已经非常具体的接口。创建的接口越多，代码就越复杂。</p>
<h4 id="依赖倒置原则-Dependency-Inversion-Principle"><a href="#依赖倒置原则-Dependency-Inversion-Principle" class="headerlink" title="依赖倒置原则(Dependency Inversion Principle)"></a>依赖倒置原则(Dependency Inversion Principle)</h4><p>高层次的类不应该依赖于低层次的类。两者都应该依赖于抽象接口。抽象接口不应依赖于具体实现。具体实现应该依赖于抽象接口。</p>
<p>通常在设计软件时，有不同层次的类：</p>
<ul>
<li><strong>低层次的类</strong>实现基础操作（例如磁盘操作、传输网络数据和连接数据库等）。</li>
<li><strong>高层次的类</strong>包含复杂业务逻辑以指导低层次的类执行特定操作。</li>
</ul>
<p>有时会先设计低层次的类， 然后才会开发高层次的类。 当低层次的东西还没有实现或不确定，就无法确定高层次类能实现哪些功能。</p>
<p>依赖倒置原则建议改变这种依赖方式。</p>
<p>例如，高层次的预算报告类使用低层次的数据库类来读取和保存其数据。低层次类中的任何改变（例如当数据库服务器发布新版本时）都可能会影响到高层次的类，但高层次的类不应关注数据存储的细节。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/image-20210128000142672.png"></p>
<p><strong>修改前：</strong>高层次的类依赖于低层次的类。</p>
<p>创建一个描述读写操作的高层接口， 并让报告类使用该接口代替低层次的类。然后可以修改或扩展低层次的原始类来实现业务逻辑声明的读写接口。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/image-20210128001951493.png"></p>
<p><strong>修改后：</strong>低层次的类依赖于高层次的抽象，原始的依赖关系被倒置。</p>
<p>有原则是件好事，但是应用这些原则可能会使程序架构变得过于复杂，要从实用的角度来考量，不能盲目遵守这些原则。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Mybatis Executor</title>
    <url>/posts/1b8eb0fb/</url>
    <content><![CDATA[<img data-src="https://mybatis.org/images/mybatis-logo.png">
<!-- <img data-src="images/images.jfif"/> -->
<!-- ![how-to-install-mysql-on-centos](https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/how-to-install-mysql-on-centos.png) -->
MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。

<p>本文介绍了 MyBatis 执行过程和 Executor 的执行体系相关内容。</p>
<span id="more"></span>

<h2 id="Mybatis-执行过程"><a href="#Mybatis-执行过程" class="headerlink" title="Mybatis 执行过程"></a>Mybatis 执行过程</h2><p>抛开通过 Mapper 接口生成动态代理，MyBatis 的一次执行过程可大致分为以下几个部分：</p>
<ol>
<li>获取门面会话</li>
<li>执行器逻辑</li>
<li>JDBC 处理器逻辑</li>
</ol>
<p>如图所示：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/mybatis/image-20210429001446963.png" alt="Mybatis 执行过程"></p>
<p>SqlSession 中提供了基本 API：增、删、改、查</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/mybatis/image-20210428202606059.png" alt="SqlSession 的方法"></p>
<p>其中 <code>select()</code> 方法有很多，他们的区别主要在参数和返回结果上。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/mybatis/image-20210428203039799.png" alt="SqlSession 的 Select() 方法"></p>
<p>返回结果上，有 <code>void</code>，游标 <code>Cursor&lt;T&gt;</code>，<code>List&lt;E&gt;</code>，<code>Map&lt;K, V&gt;</code>，一条数据 <code>T</code>。参数上，<code>String</code> 就是 StatementId，Mybatis 中所有操作（增删改查）都有一个 Id，通过 Id 找到 SQL 映射，<code>Object</code> 就是 SQL 中的参数，<code>ResultHandler</code> 对结果集进行处理，<code>RowBound</code> 用于设置返回的范围，用于进行分页。多个 <code>select()</code> 方法重载的设计用意是为了方便调用，这种方便调用进行的重载就是<code>门面模式</code>。</p>
<p>除了基本 API 之外，还有辅助 API，即提交和关闭会话。会话中可执行多个 SQL，一个会话只能被一个线程调用，线程使用完 SqlSession 后应该立马把它关闭掉，但一个线程可调用多个会话。因此，SqlSession 不能跨线程使用，也即它不是线程安全的。</p>
<p>在 MyBatis 中，DefaultSqlSession 继承了 SqlSession 接口，是 SqlSession 的默认实现，在该实现类中，包含了两个重要对象 <strong>Configuration</strong> 和 <strong>Executor</strong>。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSqlSession</span> <span class="keyword">implements</span> <span class="title">SqlSession</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Configuration configuration;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Executor executor;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> autoCommit;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> dirty;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Cursor&lt;?&gt;&gt; cursorList;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DefaultSqlSession</span><span class="params">(Configuration configuration, Executor executor, <span class="keyword">boolean</span> autoCommit)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">    <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.autoCommit = autoCommit;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DefaultSqlSession</span><span class="params">(Configuration configuration, Executor executor)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(configuration, executor, <span class="keyword">false</span>);</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>SqlSession 只提供 SQL 会话，具体执行交给 Executor。Executor 也提供了基本功能，其中包括改、查、缓存维护和事务管理。还提供了辅助 API，包括提交、关闭执行器和批处理刷新。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/mybatis/image-20210428212838383.png" alt="Executor 的方法"></p>
<p>Executor 本身也不会去执行 SQL，执行 SQL 交给了 StatementHandler，StatementHandler 本质上使用了 JDBC 中的 Statement 进行参数处理、执行 SQL 和处理结果。</p>
<p>其中 1 个 SqlSession 对应 1 个 Executor ， 1 个 Executor 对应 n 个 StatementHandler，即执行多少条 SQL 就有多少个 StatementHandler。它们都不能够跨线程调用。</p>
<h2 id="Executor-执行器体系"><a href="#Executor-执行器体系" class="headerlink" title="Executor 执行器体系"></a>Executor 执行器体系</h2><p>Executor 的继承体系：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/mybatis/BaseExecutor.svg" alt="Executor 的继承体系"></p>
<ol>
<li>BaseExecutor：基础执行器，是一个抽象类，提供了关于 SimpleExecutor、ReuseExecutor、BatchExecutor 共性相关的功能实现，此外，BaseExecutor 还与 MyBatis 的一级缓存和事务管理相关</li>
<li>SimpleExecutor：简单执行器，每次都会创建一个新的 Statement（默认是 PreparedStatement）</li>
<li>ReuseExecutor：重用执行器，相同的 SQL 语句会使用同一个 Statement</li>
<li>BatchExecutor：批处理执行器，批处理提交修改，必须执行 flushStatement 才会生效</li>
<li>CachingExecutor：缓存执行器，与 MyBatis 二级缓存相关</li>
</ol>
<h3 id="BaseExecutor"><a href="#BaseExecutor" class="headerlink" title="BaseExecutor"></a>BaseExecutor</h3><p>BaseExecutor 作为 SimpleExecutor、ReuseExecutor、BatchExecutor 的父类，实现了子类中的一些共性功能。</p>
<p>主要方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/** 事务管理接口、定义了与JDBC执行相关的功能，如获取连接、提交、回滚、关闭连接等操作 */</span></span><br><span class="line"><span class="keyword">protected</span> Transaction transaction;</span><br><span class="line"><span class="keyword">protected</span> Executor wrapper;</span><br><span class="line"><span class="comment">/** 下方三个对象均是与一级缓存相关的属性, 作用域为 BaseExecutor 的生命周期范围 */</span></span><br><span class="line"><span class="keyword">protected</span> ConcurrentLinkedQueue&lt;DeferredLoad&gt; deferredLoads;</span><br><span class="line"><span class="keyword">protected</span> PerpetualCache localCache;</span><br><span class="line"><span class="keyword">protected</span> PerpetualCache localOutputParameterCache;</span><br><span class="line"><span class="keyword">protected</span> Configuration configuration;</span><br><span class="line"><span class="comment">/** 与动态sql中的嵌套子查询相关 */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> queryStack;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> closed;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">BaseExecutor</span><span class="params">(Configuration configuration, Transaction transaction)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.transaction = transaction;</span><br><span class="line">    <span class="keyword">this</span>.deferredLoads = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">this</span>.localCache = <span class="keyword">new</span> PerpetualCache(<span class="string">"LocalCache"</span>);</span><br><span class="line">    <span class="keyword">this</span>.localOutputParameterCache = <span class="keyword">new</span> PerpetualCache(<span class="string">"LocalOutputParameterCache"</span>);</span><br><span class="line">    <span class="keyword">this</span>.closed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">    <span class="keyword">this</span>.wrapper = <span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Transaction <span class="title">getTransaction</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (closed) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> transaction;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 关闭当前对象、关闭之前判断是否需要回滚</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">boolean</span> forceRollback)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            rollback(forceRollback);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="keyword">if</span> (transaction != <span class="keyword">null</span>) {</span><br><span class="line">                transaction.close();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (SQLException e) {</span><br><span class="line">        <span class="comment">// Ignore. There's nothing that can be done at this point.</span></span><br><span class="line">        log.warn(<span class="string">"Unexpected exception on closing transaction.  Cause: "</span> + e);</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        transaction = <span class="keyword">null</span>;</span><br><span class="line">        deferredLoads = <span class="keyword">null</span>;</span><br><span class="line">        localCache = <span class="keyword">null</span>;</span><br><span class="line">        localOutputParameterCache = <span class="keyword">null</span>;</span><br><span class="line">        closed = <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isClosed</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> closed;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">"executing an update"</span>).object(ms.getId());</span><br><span class="line">    <span class="keyword">if</span> (closed) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</span><br><span class="line">    }</span><br><span class="line">    clearLocalCache();</span><br><span class="line">    <span class="keyword">return</span> doUpdate(ms, parameter);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;BatchResult&gt; <span class="title">flushStatements</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    <span class="keyword">return</span> flushStatements(<span class="keyword">false</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;BatchResult&gt; <span class="title">flushStatements</span><span class="params">(<span class="keyword">boolean</span> isRollBack)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    <span class="keyword">if</span> (closed) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> doFlushStatements(isRollBack);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    BoundSql boundSql = ms.getBoundSql(parameter);</span><br><span class="line">    CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);</span><br><span class="line">    <span class="keyword">return</span> query(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">"executing a query"</span>).object(ms.getId());</span><br><span class="line">    <span class="keyword">if</span> (closed) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) {</span><br><span class="line">        <span class="comment">// 如果不是嵌套查询，并且配置了flushCache为true，清空一级缓存</span></span><br><span class="line">        clearLocalCache();</span><br><span class="line">    }</span><br><span class="line">    List&lt;E&gt; list;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        queryStack++;</span><br><span class="line">        <span class="comment">// 如果resultHandler为空，尝试从一级缓存中获取数据</span></span><br><span class="line">        list = resultHandler == <span class="keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (list != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 与存储过程相关（CallableStatement）</span></span><br><span class="line">            handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 一级缓存中没有对应数据，从数据库查询</span></span><br><span class="line">            list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        queryStack--;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 延迟装载相关逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) {</span><br><span class="line">            deferredLoad.load();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// issue #601</span></span><br><span class="line">        deferredLoads.clear();</span><br><span class="line">        <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) {</span><br><span class="line">            <span class="comment">// 如果全局配置的一级缓存作用域为Statement，清除本地缓存，因此一级缓存无法被关闭，只是减少范围至每一个Statement</span></span><br><span class="line">            <span class="comment">// issue #482</span></span><br><span class="line">            clearLocalCache();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">Cursor&lt;E&gt; <span class="title">queryCursor</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    BoundSql boundSql = ms.getBoundSql(parameter);</span><br><span class="line">    <span class="keyword">return</span> doQueryCursor(ms, parameter, rowBounds, boundSql);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deferLoad</span><span class="params">(MappedStatement ms, MetaObject resultObject, String property, CacheKey key, Class&lt;?&gt; targetType)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (closed) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</span><br><span class="line">    }</span><br><span class="line">    DeferredLoad deferredLoad = <span class="keyword">new</span> DeferredLoad(resultObject, property, key, localCache, configuration, targetType);</span><br><span class="line">    <span class="keyword">if</span> (deferredLoad.canLoad()) {</span><br><span class="line">        deferredLoad.load();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        deferredLoads.add(<span class="keyword">new</span> DeferredLoad(resultObject, property, key, localCache, configuration, targetType));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">/** 创建CacheKey逻辑，主要与mappedStatement的ID，参数，分页参数和sql有关 */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CacheKey <span class="title">createCacheKey</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (closed) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</span><br><span class="line">    }</span><br><span class="line">    CacheKey cacheKey = <span class="keyword">new</span> CacheKey();</span><br><span class="line">    cacheKey.update(ms.getId());</span><br><span class="line">    cacheKey.update(rowBounds.getOffset());</span><br><span class="line">    cacheKey.update(rowBounds.getLimit());</span><br><span class="line">    cacheKey.update(boundSql.getSql());</span><br><span class="line">    List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">    TypeHandlerRegistry typeHandlerRegistry = ms.getConfiguration().getTypeHandlerRegistry();</span><br><span class="line">    <span class="comment">// mimic DefaultParameterHandler logic</span></span><br><span class="line">    <span class="keyword">for</span> (ParameterMapping parameterMapping : parameterMappings) {</span><br><span class="line">        <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) {</span><br><span class="line">            Object value;</span><br><span class="line">            String propertyName = parameterMapping.getProperty();</span><br><span class="line">            <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) {</span><br><span class="line">                value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject == <span class="keyword">null</span>) {</span><br><span class="line">                value = <span class="keyword">null</span>;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) {</span><br><span class="line">                value = parameterObject;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">                value = metaObject.getValue(propertyName);</span><br><span class="line">            }</span><br><span class="line">            cacheKey.update(value);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (configuration.getEnvironment() != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// issue #176</span></span><br><span class="line">        cacheKey.update(configuration.getEnvironment().getId());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> cacheKey;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCached</span><span class="params">(MappedStatement ms, CacheKey key)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> localCache.getObject(key) != <span class="keyword">null</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    <span class="keyword">if</span> (closed) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Cannot commit, transaction is already closed"</span>);</span><br><span class="line">    }</span><br><span class="line">    clearLocalCache();</span><br><span class="line">    flushStatements();</span><br><span class="line">    <span class="keyword">if</span> (required) {</span><br><span class="line">        transaction.commit();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    <span class="keyword">if</span> (!closed) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            clearLocalCache();</span><br><span class="line">            flushStatements(<span class="keyword">true</span>);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="keyword">if</span> (required) {</span><br><span class="line">                transaction.rollback();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 清空本地缓存、在BaseExecutor中，update、query、commit、rollback方法中，均有调用回滚的逻辑</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearLocalCache</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!closed) {</span><br><span class="line">        localCache.clear();</span><br><span class="line">        localOutputParameterCache.clear();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">/** 执行更新操作 */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">doUpdate</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="comment">/** 执行Statement，填充结果、与批量执行相关 */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> List&lt;BatchResult&gt; <span class="title">doFlushStatements</span><span class="params">(<span class="keyword">boolean</span> isRollback)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="comment">/** 执行查询操作 */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;E&gt; <span class="function">Cursor&lt;E&gt; <span class="title">doQueryCursor</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, BoundSql boundSql)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="comment">/** 关闭Statement对象 */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">closeStatement</span><span class="params">(Statement statement)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (statement != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            statement.close();</span><br><span class="line">        } <span class="keyword">catch</span> (SQLException e) {</span><br><span class="line">            <span class="comment">// ignore</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Apply a transaction timeout.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> statement</span></span><br><span class="line"><span class="comment">   *          a current statement</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">   *           if a database access error occurs, this method is called on a closed &lt;code&gt;Statement&lt;/code&gt;</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 3.4.0</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@see</span> StatementUtil#applyTransactionTimeout(Statement, Integer, Integer)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyTransactionTimeout</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    StatementUtil.applyTransactionTimeout(statement, statement.getQueryTimeout(), transaction.getTimeout());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleLocallyCachedOutputParameters</span><span class="params">(MappedStatement ms, CacheKey key, Object parameter, BoundSql boundSql)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) {</span><br><span class="line">        <span class="keyword">final</span> Object cachedParameter = localOutputParameterCache.getObject(key);</span><br><span class="line">        <span class="keyword">if</span> (cachedParameter != <span class="keyword">null</span> &amp;&amp; parameter != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">final</span> MetaObject metaCachedParameter = configuration.newMetaObject(cachedParameter);</span><br><span class="line">            <span class="keyword">final</span> MetaObject metaParameter = configuration.newMetaObject(parameter);</span><br><span class="line">            <span class="keyword">for</span> (ParameterMapping parameterMapping : boundSql.getParameterMappings()) {</span><br><span class="line">                <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.IN) {</span><br><span class="line">                    <span class="keyword">final</span> String parameterName = parameterMapping.getProperty();</span><br><span class="line">                    <span class="keyword">final</span> Object cachedValue = metaCachedParameter.getValue(parameterName);</span><br><span class="line">                    metaParameter.setValue(parameterName, cachedValue);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">/** 查询数据库 */</span></span><br><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    List&lt;E&gt; list;</span><br><span class="line">    <span class="comment">// 插入key和占位符，为一级缓存做准备</span></span><br><span class="line">    localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 调用子类实现的方法查询</span></span><br><span class="line">        list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        localCache.removeObject(key);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 查询结果保存到缓存中</span></span><br><span class="line">    localCache.putObject(key, list);</span><br><span class="line">    <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) {</span><br><span class="line">        localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Connection <span class="title">getConnection</span><span class="params">(Log statementLog)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    Connection connection = transaction.getConnection();</span><br><span class="line">    <span class="keyword">if</span> (statementLog.isDebugEnabled()) {</span><br><span class="line">        <span class="keyword">return</span> ConnectionLogger.newInstance(connection, statementLog, queryStack);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setExecutorWrapper</span><span class="params">(Executor wrapper)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.wrapper = wrapper;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DeferredLoad</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MetaObject resultObject;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String property;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; targetType;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CacheKey key;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PerpetualCache localCache;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ObjectFactory objectFactory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResultExtractor resultExtractor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// issue #781</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeferredLoad</span><span class="params">(MetaObject resultObject,</span></span></span><br><span class="line"><span class="params"><span class="function">                        String property,</span></span></span><br><span class="line"><span class="params"><span class="function">                        CacheKey key,</span></span></span><br><span class="line"><span class="params"><span class="function">                        PerpetualCache localCache,</span></span></span><br><span class="line"><span class="params"><span class="function">                        Configuration configuration,</span></span></span><br><span class="line"><span class="params"><span class="function">                        Class&lt;?&gt; targetType)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.resultObject = resultObject;</span><br><span class="line">        <span class="keyword">this</span>.property = property;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.localCache = localCache;</span><br><span class="line">        <span class="keyword">this</span>.objectFactory = configuration.getObjectFactory();</span><br><span class="line">        <span class="keyword">this</span>.resultExtractor = <span class="keyword">new</span> ResultExtractor(configuration, objectFactory);</span><br><span class="line">        <span class="keyword">this</span>.targetType = targetType;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canLoad</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> localCache.getObject(key) != <span class="keyword">null</span> &amp;&amp; localCache.getObject(key) != EXECUTION_PLACEHOLDER;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line">        <span class="comment">// we suppose we get back a List</span></span><br><span class="line">        List&lt;Object&gt; list = (List&lt;Object&gt;) localCache.getObject(key);</span><br><span class="line">        Object value = resultExtractor.extractObjectFromList(list, targetType);</span><br><span class="line">        resultObject.setValue(property, value);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>BaseExecutor 主要为了子类提供了一些共性方法的实现，如事务相关的提交和回滚，一级缓存和获取数据库连接等。同时，定义了 doQuery、doUpdate、doFlushStatement 等抽象方法，由对应的子类去实现具体逻辑。以 query 方法为例，在 queryFormDatabase 中最终调用 doQuery 执行查询。</p>
<h3 id="SimpleExecutor"><a href="#SimpleExecutor" class="headerlink" title="SimpleExecutor"></a>SimpleExecutor</h3><p>SimpleExecutor 是简单执行器，MyBatis 默认配置的执行器，如果没有配置指定执行器，使用的都是 SimpleExecutor。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleExecutor</span> <span class="keyword">extends</span> <span class="title">BaseExecutor</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleExecutor</span><span class="params">(Configuration configuration, Transaction transaction)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>(configuration, transaction);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doUpdate</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">        Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Configuration configuration = ms.getConfiguration();</span><br><span class="line">            StatementHandler handler = configuration.newStatementHandler(<span class="keyword">this</span>, ms, parameter, RowBounds.DEFAULT, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">            <span class="keyword">return</span> handler.update(stmt);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            closeStatement(stmt);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">        Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Configuration configuration = ms.getConfiguration();</span><br><span class="line">            StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">            stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">            <span class="keyword">return</span> handler.query(stmt, resultHandler);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            closeStatement(stmt);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;E&gt; <span class="function">Cursor&lt;E&gt; <span class="title">doQueryCursor</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">        Configuration configuration = ms.getConfiguration();</span><br><span class="line">        StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, <span class="keyword">null</span>, boundSql);</span><br><span class="line">        Statement stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">        Cursor&lt;E&gt; cursor = handler.queryCursor(stmt);</span><br><span class="line">        stmt.closeOnCompletion();</span><br><span class="line">        <span class="keyword">return</span> cursor;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;BatchResult&gt; <span class="title">doFlushStatements</span><span class="params">(<span class="keyword">boolean</span> isRollback)</span> </span>{</span><br><span class="line">        <span class="comment">// doFlushStatements 只是给 batch 用的，所以这里返回空</span></span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Statement <span class="title">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">        Statement stmt;</span><br><span class="line">        Connection connection = getConnection(statementLog);</span><br><span class="line">        stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">        handler.parameterize(stmt);</span><br><span class="line">        <span class="keyword">return</span> stmt;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以查询为例，当调用 query 方法时，经过 BaseExecutor 的处理后，调用 queryFormDataBase 时，其内部又调用了doQuery 方法。所以实际上，真正去执行查询的方法为对应执行器的 doQuery 实现。但是在 SimpleExecutor 的 doQuery 方法中，我们可以看到，在 executor 层其实只做了三件事。</p>
<ol>
<li>通过当前绑定执行的 MappedStatement 去获取一个对应的 StatementHandler 对象</li>
<li>创建 Connection 连接并生成 Statement 对象，并进行参数处理，每次使用 SimpleExecutor 执行查询或更新时，都会创建一个 Statement 对象</li>
<li>交由对应的 StatementHandler 去执行 Statement</li>
</ol>
<h3 id="ReuseExecutor"><a href="#ReuseExecutor" class="headerlink" title="ReuseExecutor"></a>ReuseExecutor</h3><p>ReuseExecutor 名为重用执行器。重用执行器的作用是在一次会话中，重复使用同一个 Statement 对象以提升性能。以查询为例，每次执行查询时，都会去 Statement 缓存中查找，如果已经存在相同 SQL 的 Statement 对象，就会重复使用同一个 Statement 对象。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReuseExecutor</span> <span class="keyword">extends</span> <span class="title">BaseExecutor</span> </span>{</span><br><span class="line">    <span class="comment">/** 可重用的执行器内部用了一个map，用来缓存SQL语句对应的Statement，即key为SQL */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Statement&gt; statementMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReuseExecutor</span><span class="params">(Configuration configuration, Transaction transaction)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>(configuration, transaction);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doUpdate</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">        Configuration configuration = ms.getConfiguration();</span><br><span class="line">        <span class="comment">// 新建一个StatementHandler</span></span><br><span class="line">        StatementHandler handler = configuration.newStatementHandler(<span class="keyword">this</span>, ms, parameter, RowBounds.DEFAULT, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 准备语句</span></span><br><span class="line">        Statement stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">        <span class="keyword">return</span> handler.update(stmt);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">        Configuration configuration = ms.getConfiguration();</span><br><span class="line">        StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        Statement stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">        <span class="keyword">return</span> handler.query(stmt, resultHandler);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;E&gt; <span class="function">Cursor&lt;E&gt; <span class="title">doQueryCursor</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">        Configuration configuration = ms.getConfiguration();</span><br><span class="line">        StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, <span class="keyword">null</span>, boundSql);</span><br><span class="line">        Statement stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">        <span class="keyword">return</span> handler.queryCursor(stmt);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;BatchResult&gt; <span class="title">doFlushStatements</span><span class="params">(<span class="keyword">boolean</span> isRollback)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (Statement stmt : statementMap.values()) {</span><br><span class="line">            closeStatement(stmt);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// flush的时候清除缓存</span></span><br><span class="line">        statementMap.clear();</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Statement <span class="title">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">        Statement stmt;</span><br><span class="line">        <span class="comment">// 得到绑定的SQL语句</span></span><br><span class="line">        BoundSql boundSql = handler.getBoundSql();</span><br><span class="line">        String sql = boundSql.getSql();</span><br><span class="line">        <span class="comment">// 如果缓存中已经有了Statement，直接获取</span></span><br><span class="line">        <span class="keyword">if</span> (hasStatementFor(sql)) {</span><br><span class="line">            stmt = getStatement(sql);</span><br><span class="line">            applyTransactionTimeout(stmt);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 如果没有，prepare一个放入缓存</span></span><br><span class="line">            Connection connection = getConnection(statementLog);</span><br><span class="line">            stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">            putStatement(sql, stmt);</span><br><span class="line">        }</span><br><span class="line">        handler.parameterize(stmt);</span><br><span class="line">        <span class="keyword">return</span> stmt;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasStatementFor</span><span class="params">(String sql)</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Statement statement = statementMap.get(sql);</span><br><span class="line">            <span class="keyword">return</span> statement != <span class="keyword">null</span> &amp;&amp; !statement.getConnection().isClosed();</span><br><span class="line">        } <span class="keyword">catch</span> (SQLException e) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Statement <span class="title">getStatement</span><span class="params">(String s)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> statementMap.get(s);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putStatement</span><span class="params">(String sql, Statement stmt)</span> </span>{</span><br><span class="line">        statementMap.put(sql, stmt);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>ReuseExecutor 实现 Statement 对象的复用逻辑很简单，在类内部维护一个 Map，使用对应的 SQL 作为 key 来缓存同个会话中的 Statement 对象，每次需要执行时，都先去本地的缓存 Map 中查找，如果存在则直接使用之前的 Statement 对象，如果不存在再去创建 Statement 对象。</p>
<h3 id="BatchExecutor"><a href="#BatchExecutor" class="headerlink" title="BatchExecutor"></a>BatchExecutor</h3><p>BatchExecutor 名为批量处理器，用来批量执行 SQL，但是注意，批量处理只对更新（增删改）语句有效，对查询无效。在同一个会话内，增删改 SQL 会一次性处理好 SQL 和参数然后发送给数据库，从而减少与数据库的交互次数，减少 IO 消耗，提升性能。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BatchExecutor</span> <span class="keyword">extends</span> <span class="title">BaseExecutor</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BATCH_UPDATE_RETURN_VALUE = Integer.MIN_VALUE + <span class="number">1002</span>;</span><br><span class="line">    <span class="comment">/** 批量执行的Statement对象 **/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Statement&gt; statementList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">/** 批量执行的结果对象 **/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;BatchResult&gt; batchResultList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">/** 上一次处理的SQL语句 **/</span></span><br><span class="line">    <span class="keyword">private</span> String currentSql;</span><br><span class="line">    <span class="comment">/** 上一次处理的MappedStatement对象 **/</span></span><br><span class="line">    <span class="keyword">private</span> MappedStatement currentStatement;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BatchExecutor</span><span class="params">(Configuration configuration, Transaction transaction)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>(configuration, transaction);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doUpdate</span><span class="params">(MappedStatement ms, Object parameterObject)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">        <span class="keyword">final</span> Configuration configuration = ms.getConfiguration();</span><br><span class="line">        <span class="keyword">final</span> StatementHandler handler = configuration.newStatementHandler(<span class="keyword">this</span>, ms, parameterObject, RowBounds.DEFAULT, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">final</span> BoundSql boundSql = handler.getBoundSql();</span><br><span class="line">        <span class="comment">// 获取SQL语句</span></span><br><span class="line">        <span class="keyword">final</span> String sql = boundSql.getSql();</span><br><span class="line">        <span class="keyword">final</span> Statement stmt;</span><br><span class="line">        <span class="comment">// 判断当前要处理的sql语句是否等于上一次执行的sql，MappedStatement也是同理</span></span><br><span class="line">        <span class="comment">// 只有这两个对象都满足时，才能复用上一次的Statement对象</span></span><br><span class="line">        <span class="keyword">if</span> (sql.equals(currentSql) &amp;&amp; ms.equals(currentStatement)) {</span><br><span class="line">            <span class="keyword">int</span> last = statementList.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 即使满足上述的两个条件，也只能从statement缓存list中获取最后一个对象，相同的sql还必须满足连贯顺序才能复用上一次的Statement对象</span></span><br><span class="line">            stmt = statementList.get(last);</span><br><span class="line">            applyTransactionTimeout(stmt);</span><br><span class="line">            handler.parameterize(stmt);<span class="comment">// fix Issues 322</span></span><br><span class="line">            BatchResult batchResult = batchResultList.get(last);</span><br><span class="line">            batchResult.addParameterObject(parameterObject);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 创建和保存新的Statement对象和BatchResult对象</span></span><br><span class="line">            <span class="comment">// 并将当前sql和MappedStatement设置为该次执行的对应对象</span></span><br><span class="line">            Connection connection = getConnection(ms.getStatementLog());</span><br><span class="line">            stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">            handler.parameterize(stmt);    <span class="comment">// fix Issues 322</span></span><br><span class="line">            currentSql = sql;</span><br><span class="line">            currentStatement = ms;</span><br><span class="line">            statementList.add(stmt);</span><br><span class="line">            batchResultList.add(<span class="keyword">new</span> BatchResult(ms, sql, parameterObject));</span><br><span class="line">        }</span><br><span class="line">        handler.batch(stmt);</span><br><span class="line">        <span class="keyword">return</span> BATCH_UPDATE_RETURN_VALUE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">        Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            flushStatements();</span><br><span class="line">            Configuration configuration = ms.getConfiguration();</span><br><span class="line">            StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">            Connection connection = getConnection(ms.getStatementLog());</span><br><span class="line">            stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">            handler.parameterize(stmt);</span><br><span class="line">            <span class="keyword">return</span> handler.query(stmt, resultHandler);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            closeStatement(stmt);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;E&gt; <span class="function">Cursor&lt;E&gt; <span class="title">doQueryCursor</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">        flushStatements();</span><br><span class="line">        Configuration configuration = ms.getConfiguration();</span><br><span class="line">        StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, <span class="keyword">null</span>, boundSql);</span><br><span class="line">        Connection connection = getConnection(ms.getStatementLog());</span><br><span class="line">        Statement stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">        handler.parameterize(stmt);</span><br><span class="line">        Cursor&lt;E&gt; cursor = handler.queryCursor(stmt);</span><br><span class="line">        stmt.closeOnCompletion();</span><br><span class="line">        <span class="keyword">return</span> cursor;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;BatchResult&gt; <span class="title">doFlushStatements</span><span class="params">(<span class="keyword">boolean</span> isRollback)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            List&lt;BatchResult&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span> (isRollback) {</span><br><span class="line">                <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = statementList.size(); i &lt; n; i++) {</span><br><span class="line">                Statement stmt = statementList.get(i);</span><br><span class="line">                applyTransactionTimeout(stmt);</span><br><span class="line">                BatchResult batchResult = batchResultList.get(i);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="comment">// 执行并记录批量执行的数量</span></span><br><span class="line">                    batchResult.setUpdateCounts(stmt.executeBatch());</span><br><span class="line">                    MappedStatement ms = batchResult.getMappedStatement();</span><br><span class="line">                    List&lt;Object&gt; parameterObjects = batchResult.getParameterObjects();</span><br><span class="line">                    KeyGenerator keyGenerator = ms.getKeyGenerator();</span><br><span class="line">                    <span class="keyword">if</span> (Jdbc3KeyGenerator.class.equals(keyGenerator.getClass())) {</span><br><span class="line">                        Jdbc3KeyGenerator jdbc3KeyGenerator = (Jdbc3KeyGenerator) keyGenerator;</span><br><span class="line">                        jdbc3KeyGenerator.processBatch(ms, stmt, parameterObjects);</span><br><span class="line">                    } <span class="keyword">else</span> <span class="keyword">if</span> (!NoKeyGenerator.class.equals(keyGenerator.getClass())) { <span class="comment">//issue #141</span></span><br><span class="line">                        <span class="keyword">for</span> (Object parameter : parameterObjects) {</span><br><span class="line">                            keyGenerator.processAfter(<span class="keyword">this</span>, ms, stmt, parameter);</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">// Close statement to close cursor #1109</span></span><br><span class="line">                    closeStatement(stmt);</span><br><span class="line">                } <span class="keyword">catch</span> (BatchUpdateException e) {</span><br><span class="line">                    StringBuilder message = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                    message.append(batchResult.getMappedStatement().getId())</span><br><span class="line">                        .append(<span class="string">" (batch index #"</span>)</span><br><span class="line">                        .append(i + <span class="number">1</span>)</span><br><span class="line">                        .append(<span class="string">")"</span>)</span><br><span class="line">                        .append(<span class="string">" failed."</span>);</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) {</span><br><span class="line">                        message.append(<span class="string">" "</span>)</span><br><span class="line">                            .append(i)</span><br><span class="line">                            .append(<span class="string">" prior sub executor(s) completed successfully, but will be rolled back."</span>);</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BatchExecutorException(message.toString(), e, results, batchResult);</span><br><span class="line">                }</span><br><span class="line">                results.add(batchResult);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> results;</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="keyword">for</span> (Statement stmt : statementList) {</span><br><span class="line">                closeStatement(stmt);</span><br><span class="line">            }</span><br><span class="line">            currentSql = <span class="keyword">null</span>;</span><br><span class="line">            statementList.clear();</span><br><span class="line">            batchResultList.clear();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>值得注意的时，在使用 BatchExecutor 的时候，如果是相同的 SQL 语句，会进行合并使用同一个 Statement 对象，但是有一个前提是，相同的 SQL 语句必须是相同的 MappedStatement，并且 SQL 必须满足连贯的先后顺序。</p>
<h3 id="CachingExecutor"><a href="#CachingExecutor" class="headerlink" title="CachingExecutor"></a>CachingExecutor</h3><p>CachingExecutor是缓存执行器，用于实现MyBatis的二级缓存，直接继承与Executor。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachingExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 装饰者模式内部持有一个Executor */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Executor delegate;</span><br><span class="line">    <span class="comment">/** 事务缓存管理器 **/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TransactionalCacheManager tcm = <span class="keyword">new</span> TransactionalCacheManager();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CachingExecutor</span><span class="params">(Executor delegate)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">        delegate.setExecutorWrapper(<span class="keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Transaction <span class="title">getTransaction</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> delegate.getTransaction();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">boolean</span> forceRollback)</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// issues #499, #524 and #573</span></span><br><span class="line">            <span class="keyword">if</span> (forceRollback) {</span><br><span class="line">                tcm.rollback();</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                tcm.commit();</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            delegate.close(forceRollback);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isClosed</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> delegate.isClosed();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(MappedStatement ms, Object parameterObject)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">        flushCacheIfRequired(ms);</span><br><span class="line">        <span class="keyword">return</span> delegate.update(ms, parameterObject);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function">Cursor&lt;E&gt; <span class="title">queryCursor</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">        flushCacheIfRequired(ms);</span><br><span class="line">        <span class="keyword">return</span> delegate.queryCursor(ms, parameter, rowBounds);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">        BoundSql boundSql = ms.getBoundSql(parameterObject);</span><br><span class="line">        CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">        <span class="keyword">return</span> query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">        Cache cache = ms.getCache();</span><br><span class="line">        <span class="keyword">if</span> (cache != <span class="keyword">null</span>) {</span><br><span class="line">            flushCacheIfRequired(ms);</span><br><span class="line">            <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) {</span><br><span class="line">                ensureNoOutParams(ms, boundSql);</span><br><span class="line">                <span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line">                List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line">                <span class="keyword">if</span> (list == <span class="keyword">null</span>) {</span><br><span class="line">                    list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">                    tcm.putObject(cache, key, list); <span class="comment">// issue #578 and #116</span></span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> list;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;BatchResult&gt; <span class="title">flushStatements</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">        <span class="keyword">return</span> delegate.flushStatements();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">        delegate.commit(required);</span><br><span class="line">        tcm.commit();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            delegate.rollback(required);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="keyword">if</span> (required) {</span><br><span class="line">                tcm.rollback();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureNoOutParams</span><span class="params">(MappedStatement ms, BoundSql boundSql)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) {</span><br><span class="line">            <span class="keyword">for</span> (ParameterMapping parameterMapping : boundSql.getParameterMappings()) {</span><br><span class="line">                <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.IN) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Caching stored procedures with OUT params is not supported.  Please configure useCache=false in "</span> + ms.getId() + <span class="string">" statement."</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheKey <span class="title">createCacheKey</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> delegate.createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCached</span><span class="params">(MappedStatement ms, CacheKey key)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> delegate.isCached(ms, key);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deferLoad</span><span class="params">(MappedStatement ms, MetaObject resultObject, String property, CacheKey key, Class&lt;?&gt; targetType)</span> </span>{</span><br><span class="line">        delegate.deferLoad(ms, resultObject, property, key, targetType);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearLocalCache</span><span class="params">()</span> </span>{</span><br><span class="line">        delegate.clearLocalCache();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushCacheIfRequired</span><span class="params">(MappedStatement ms)</span> </span>{</span><br><span class="line">        Cache cache = ms.getCache();</span><br><span class="line">        <span class="keyword">if</span> (cache != <span class="keyword">null</span> &amp;&amp; ms.isFlushCacheRequired()) {</span><br><span class="line">            tcm.clear(cache);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setExecutorWrapper</span><span class="params">(Executor executor)</span> </span>{</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"This method should not be called"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>CachingExecutor 通过装饰者模式，在内部持有一个 Executor 对象，包装上缓存实现逻辑。同时，CachingExecutor 中还有一个事务缓存管理器来实现事务数据的隔离性。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>MyBatis 的 Executor 方法执行栈：</p>
<ol>
<li><p>当查询时，通过 SqlSession 的 selectList 方法进行开始执行（不管是执行 selectOne 方法还是 selectList 方法，最终调用的方法都是 selectList）。SqlSession 再调用内部持有的 Executor 的 query 方法执行。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> </span>{</span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    <span class="comment">// 根据statement id找到对应的MappedStatement</span></span><br><span class="line">    MappedStatement ms = configuration.getMappedStatement(statement);</span><br><span class="line">    <span class="comment">// 转而用执行器来查询结果,注意这里传入的ResultHandler是null</span></span><br><span class="line">    <span class="keyword">return</span> executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">  } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error querying database.  Cause: "</span> + e, e);</span><br><span class="line">  } <span class="keyword">finally</span> {</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>在开启二级缓存的时候，SqlSession 内部的 Executor 对象实际上是 CachingExecutor 对象，在执行完相应的缓存逻辑后，调用 CachingExecutor 内部 Executor 对象的 query 方法。</p>
</li>
<li><p>由于在 query 方法的实现只在 BaseExecutor 中，也就是说，当 CachingExecutor 调用 query 方法时，实际上是在调用 BaseExecutor 的 query 方法。</p>
</li>
<li><p>最终执行查询时，会进入SimpleExecutor的doQuery方法，去完成一次真正的数据库查询</p>
</li>
</ol>
<p>最终 Executor 的执行体系如下图：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/mybatis/image-20210429000500432.png" alt="Executor 的执行体系"></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
</search>
