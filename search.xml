<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CentOS 7 上安装 MySQL 5.7</title>
    <url>/posts/f35f8af2/</url>
    <content><![CDATA[<img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/how-to-install-mysql-on-centos.png" height="200px">
<!-- <img data-src="images/images.jfif"/> -->
<!-- ![how-to-install-mysql-on-centos](https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/how-to-install-mysql-on-centos.png) -->
本文介绍了在 CentOS 7 上安装 MySQL 5.7 的过程，作为笔记方便以后查看。
<a id="more"></a>
## 开始安装

<p>卸载自带 mariadb 和已安装的 MySQL，如遇到依赖问题导致卸载出错则加上 <code>--nodeps</code> 参数：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 停止服务</span></span><br><span class="line">systemctl stop mysqld mariadb</span><br><span class="line">systemctl <span class="built_in">disable</span> mysqld mariadb</span><br><span class="line"><span class="comment"># 卸载已安装服务</span></span><br><span class="line">rpm -qa | grep mysql | xargs rpm -e</span><br><span class="line">rpm -qa | grep mariadb | xargs rpm -e --nodeps</span><br><span class="line"><span class="comment"># 删除相关文件</span></span><br><span class="line">rm -rvf /etc/my.cnf /var/lib/mysql /var/<span class="built_in">log</span>/mysqld.log</span><br><span class="line"><span class="comment"># 删除用户，非必须</span></span><br><span class="line">userdel -rf mysql</span><br></pre></td></tr></tbody></table></figure>

<h2 id="下载安装-MySQL"><a href="#下载安装-MySQL" class="headerlink" title="下载安装 MySQL"></a>下载安装 MySQL</h2><h3 id="网络畅通推荐使用-YUM"><a href="#网络畅通推荐使用-YUM" class="headerlink" title="网络畅通推荐使用 YUM"></a>网络畅通推荐使用 YUM</h3><p>下载 Repository：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">wget -c http://repo.mysql.com/mysql57-community-release-el7-10.noarch.rpm <span class="comment">#  -c 断点续传</span></span><br></pre></td></tr></tbody></table></figure>

<p>安装 Repository：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">yum -y install mysql57-community-release-el7-10.noarch.rpm</span><br></pre></td></tr></tbody></table></figure>

<p>安装服务器：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">yum -y install mysql-community-server</span><br></pre></td></tr></tbody></table></figure>

<h3 id="无网络先在有网络的地方下载安装包"><a href="#无网络先在有网络的地方下载安装包" class="headerlink" title="无网络先在有网络的地方下载安装包"></a>无网络先在有网络的地方下载安装包</h3><p>下载地址：<a href="https://downloads.mysql.com/archives/community/">https://downloads.mysql.com/archives/community/</a>，选择对应版本下载。</p>
<blockquote>
<p>推荐下载 mysql-5.7.30-1.el7.x86_64.rpm-bundle.tar</p>
</blockquote>
<p>解压下载的 tar 包，按如下顺序安装：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">rpm -ivh mysql-community-common-5.7.30-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-libs-5.7.30-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-client-5.7.30-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-server-5.7.30-1.el7.x86_64.rpm</span><br></pre></td></tr></tbody></table></figure>

<h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><p>启动服务：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">systemctl start mysqld</span><br></pre></td></tr></tbody></table></figure>

<p>设置开机启动：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> mysqld</span><br><span class="line">systemctl daemon-reload</span><br></pre></td></tr></tbody></table></figure>

<h2 id="修改登录密码"><a href="#修改登录密码" class="headerlink" title="修改登录密码"></a>修改登录密码</h2><p>查看安装完之后 root 用户的临时密码：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">grep <span class="string">"temporary password"</span> /var/<span class="built_in">log</span>/mysqld.log | awk -F <span class="string">" "</span> <span class="string">'{print $11}'</span> | awk <span class="string">'END{print}'</span></span><br></pre></td></tr></tbody></table></figure>

<p>登录 MySQL，第一次登录需要修改密码之后才能操作：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></tbody></table></figure>

<p>输入临时密码登录，然后修改用户密码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">mysql&gt; ALTER USER 'root'@'localhost' IDENTIFIED BY '你的密码';</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意：</p>
<p>MySQL 内置默认密码策略较严格，如需使用较简单的密码，先修改复杂密码之后方可修改密码策略。</p>
<p>查看密码策略：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE "%password%";</span><br></pre></td></tr></tbody></table></figure>

<p>修改密码长度，最短为 4，设置低于 4 仍然为 4：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">mysql&gt; SET GLOBAL validate_password_length=4;</span><br></pre></td></tr></tbody></table></figure>

<p>修改密码强度：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">mysql&gt; SET GLOBAL validate_password_policy=0;</span><br></pre></td></tr></tbody></table></figure>

<p>再通过上述 <code>ALTER USER</code> 修改较简单的密码。</p>
<p>此时为临时修改，永久修改需要修改 MySQL 配置文件 /etc/my.conf。</p>
<p>将以下内容添加到 /etc/my.conf 中：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">validate_password_policy=0</span><br><span class="line">validate_password_length=4</span><br></pre></td></tr></tbody></table></figure>

<p>重启服务即可：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">systemctl restart mysqld </span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p>刷新权限：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br></pre></td></tr></tbody></table></figure>

<p>允许远程登录：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '你的密码' WITH GRANT OPTION;</span><br></pre></td></tr></tbody></table></figure>

<p>退出：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">mysql&gt; exit</span><br></pre></td></tr></tbody></table></figure>

<h2 id="开放-3306-端口或者关闭防火墙"><a href="#开放-3306-端口或者关闭防火墙" class="headerlink" title="开放 3306 端口或者关闭防火墙"></a>开放 3306 端口或者关闭防火墙</h2><p>开放 3306 端口：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --add-port=3306/tcp</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>查看防火墙规则：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">firewall-cmd --list-all</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p>关闭防火墙：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></tbody></table></figure>

<p>取消防火墙开机自启：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line">systemctl daemon-reload</span><br></pre></td></tr></tbody></table></figure>

<h2 id="配置-MySQL-默认编码"><a href="#配置-MySQL-默认编码" class="headerlink" title="配置 MySQL 默认编码"></a>配置 MySQL 默认编码</h2><p>配置 MySQL 默认编码为 utf8，修改 MySQL 配置文件 /etc/my.conf。</p>
<p>将以下内容添加到 /etc/my.conf 中：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">character_set_server=utf8</span><br><span class="line">init_connect=<span class="string">'SET NAMES utf8'</span></span><br></pre></td></tr></tbody></table></figure>

<p>重启服务即可：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">systemctl restart mysqld </span><br></pre></td></tr></tbody></table></figure>

<p>登录 MySQL 查看是否修改成功：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">mysql&gt; show variables like '%character%';</span><br></pre></td></tr></tbody></table></figure>

<h2 id="安装完成"><a href="#安装完成" class="headerlink" title="安装完成"></a>安装完成</h2><p>完成上述步骤后就完成了 CentOS7 下 MySQL 5.7 Server 的安装，可使用 Navicat 等数据库管理软件连接。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>技术</category>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 容器 - 概述</title>
    <url>/posts/81a892b9/</url>
    <content><![CDATA[<img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/logo-java-text-color.svg" height="200px">

<p>本系列旨在归纳总结 Java 容器相关类的知识，并深入分析常用容器类的源代码。本文简单描述了 Java 容器相关概念。</p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一个程序在运行过程中会根据某些条件创建多个对象，这些条件和创建对象的个数在运行之前都是未知的。为此，Java 提供了多种方式来保存对象（对象的引用）。比如数组，但是数组的大小在创建时就已固定，不适合复杂的持有对象的场景。除此之外，Java 类库中还提供了一套容器类来解决这个问题。</p>
<p>其中基本的类型是 <strong>List</strong>、<strong>Set</strong>、<strong>Queue</strong> 和 <strong>Map</strong>，这些对象类型也称为<em>集合类</em>，但由于 Java 类库中使用了 <strong>Collection</strong> 这个名词指代某一对象，所以把这些用来保存对象的类统称为“容器”。</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p>JDK 8 中 Collection 和 Map 的类图如下所示：<br><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/Collection.svg" alt="Collection"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/Map.svg" alt="Map"></p>
<p>其中单独列出的接口和类：</p>
<ul>
<li><p>Comparator</p>
<p>比较器接口，是一个函数式接口，可通过实现其方法 <code>compare()</code> 对容器中的元素进行排序。</p>
</li>
<li><p>RandomAccess</p>
<p>是一个空接口，标识一个 <code>List</code> 是否支持快速随机访问，一个 List 支持快速随机访问时，使用 for 循环遍历比采用 Iterator 迭代器遍历更快速。实现类：<code>ArrayList</code>，<code>AttributeList</code>，<code>CopyOnWriteArrayList</code>，<code>RoleList</code>，<code>RoleUnresolvedList</code>，<code>Stack</code>，<code>Vector</code>。</p>
</li>
<li><p>Iterator 和 ListIterator</p>
<p><code>Iterator</code> 接口使用了迭代器设计模式来对所有的容器进行快速遍历，容器本身不需要关注存储元素的数据类型，这些确定类型和转型的工作由 <code>Iterator</code> 负责实现。<code>Iterator</code> 只支持<code>hasNext()</code>、<code>next()</code>、<code>remove()</code> 三种操作，而 <code>ListIterator</code> 是 List 容器所独有的迭代器，与 <code>Iterator</code> 相比，<code>ListIterator</code> 还包含 <code>add()</code>、<code>hasPrevious()</code>、<code>previous()</code>、<code>nextIndex()</code>、<code>previousIndex()</code>、<code>set()</code>  等方法，能够在遍历过程中修改集合、逆向顺序遍历、定位遍历索引；而 <code>Iterator</code> 只能遍历不能修改、只能顺向顺序遍历、不能定位索引。</p>
</li>
<li><p>Iterable</p>
<p>允许实现此接口的对象使用 <code>for-each loop</code>。<code>Iterable</code> 接口的实现又依赖于实现了 <code>Iterator</code> 的内部类(参照 <code>LinkedList</code> 中 <code>listIterator()</code> 和 <code>descendingIterator()</code> 的 JDK 源码)。有的容器类会有多个实现 <code>Iterator</code> 接口的内部类，通过返回不同的迭代器实现不同的迭代方式。</p>
</li>
<li><p>Arrays 和 Collections</p>
<p><code>Arrays</code> 是关于数组的封装类，封装了对数组操作的多种方法，如 <code>sort()</code>、<code>copyOf()</code>、<code>binarySearch()</code>、<code>asList()</code> 等方法；<code>Collections</code> 封装了很多对于容器的操作，如 <code>max()</code>、<code>min()</code>、<code>reverse()</code>、<code>sort()</code> 等方法，生成同步容器如 <code>Collections.synchronizedList()</code>、<code>Collections.synchronizedSet()</code> 等。</p>
</li>
</ul>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set 的值是不可重复的，无序的，最多只有一个 <code>null</code> 值。</p>
<p>其子容器主要包括：</p>
<ul>
<li>AbstractSet：抽象集合类，实现了 <code>equals()</code> 和 <code>hashCode()</code> 方法</li>
<li>SortedSet：有序（默认自然序）</li>
<li>NavigableSet：继承自 <code>SortedSet</code></li>
<li>TreeSet：实现 <code>NavigableSet</code> 接口，继承 <code>AbstractSet</code></li>
<li>HashSet：hash 方式存储（实际上是一个 Map 的实例）</li>
<li>LinkedHashSet：双向循环链表，不可重复，顺序与插入顺序保持一致，或者实现自定义的顺序</li>
<li>EmumSet：只能存放 <code>Emum</code> 枚举类型</li>
</ul>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List 的值是可重复的、无序的、可添加 <code>null</code> 值。</p>
<p>List 子容器主要包括：</p>
<ul>
<li>ArrayList：数组实现，随机存取</li>
<li>LinkedList：双向循环链表，顺序存取</li>
<li>Vector：同步，其他与 <code>ArrayList</code> 相同</li>
<li>Stack：同步，继承自 <code>Vector</code>，“先进后出”</li>
</ul>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>Queue 实现了数据结构中的队列，具有“先进先出”的特点。</p>
<p>主要的子容器包括：</p>
<ul>
<li>AbstractQueue：抽象队列</li>
<li>PriorityQueue：继承自 <code>AbstractQueue</code>，数据结构中堆 Heap 的实现</li>
<li>Deque：双端队列，两端都可以插入和删除 <ul>
<li>输出受限的双端队列 </li>
<li>输入受限的双端队列 </li>
</ul>
</li>
</ul>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map 容器是利用映射关系来存储键值对的，独立于 <code>List</code>、<code>Set</code>、<code>Queue</code>。键值对是一一对应的关系，一般允许键值为空，不可重复，是完全抽象类 <code>Dictionary</code> 的接口版本。</p>
<p>Map的子容器主要包括：</p>
<ul>
<li>AbstractMap：实现了内部 <code>EntrySet</code> 接口，实现 <code>equals()</code>、<code>hashCode()</code> 方法</li>
<li>SortedMap：有序（默认自然序）</li>
<li>NavigableMap：继承自 <code>SortMap</code></li>
<li>TreeMap：基于红黑树，实现 <code>NavigableMap</code> 接口，继承 <code>Abstractmap</code></li>
<li>HashMap：非同步，允许 <code>null</code></li>
<li>LinkedHashMap：非同步，允许 <code>null</code>，双向循环链表，顺序与插入顺序一致（类比于 <code>LinkedHashSet</code> ），或者实现自定义顺序。</li>
<li>HashTable：同步，不允许 <code>null</code></li>
<li>EmumMap：只能存放 <code>Emum</code> 枚举类型</li>
<li>WeakHashMap：弱键（weak key）映射，允许释放映射所指向的对象，为解决某类特殊问题而设计。如果映射之外没有应用指向某个“键”，则该“键”可以被 GC 回收</li>
<li>IdentityHashMap：使用“==”代替 <code>equals()</code> 对键进行比较的散列映射，专门为解决特殊问题而设计</li>
<li>ConcurrentHashMap：线程安全的 <code>Map</code>，属于 <code>java.util.concurrent</code> 并发包中</li>
</ul>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/WZD2012/article/details/73245493?utm_source=blogxgwz5">https://blog.csdn.net/WZD2012/article/details/73245493?utm_source=blogxgwz5</a></p>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>技术</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java 集合</tag>
      </tags>
  </entry>
  <entry>
    <title>RPM 介绍及打包总结</title>
    <url>/posts/22fd6dd2/</url>
    <content><![CDATA[<img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/RPM_Logo.svg" height="200px">
RPM Package Manager (RPM) 是一个强大的命令行驱动的软件包管理工具，用来安装、卸载、校验、查询和更新 Linux 系统上的软件包。本文简单介绍了一下 RPM，并总结制作了 RPM 包的流程。

<a id="more"></a>

<h2 id="软件包管理系统和Linux发行版"><a href="#软件包管理系统和Linux发行版" class="headerlink" title="软件包管理系统和Linux发行版"></a>软件包管理系统和Linux发行版</h2><p>软件包管理系统：自动安装、配置、卸载和升级软件包的工具组合。</p>
<p>Linux 发行版中常见的有：</p>
<ul>
<li>RPM(Redhat Package Manager)</li>
<li>DPKG(Debian Package)</li>
</ul>
<p>使用他们的系统被分为两大派系:</p>
<ul>
<li>RedHat 系（CentOS、Fedora 等）</li>
<li>Debian 系（Ubuntu、Deepin 等）</li>
</ul>
<h2 id="RPM"><a href="#RPM" class="headerlink" title="RPM"></a>RPM</h2><p>一个 RPM 包包含了已经压缩的软件文件集和相关的软件内容信息，通常表现为以 <code>.rpm</code> 扩展名结尾的文件，如果是源代码包通常以 <code>src.rpm</code> 结尾。</p>
<h3 id="rpm-包命名"><a href="#rpm-包命名" class="headerlink" title="rpm 包命名"></a>rpm 包命名</h3><p>一般格式为：<code>name-version-release.arch.rpm</code>。</p>
<ul>
<li><code>name</code>：安装包的名称。</li>
<li><code>version</code>：版本信息。</li>
<li><code>release</code>：发行号、适应系统等。</li>
<li><code>arch</code>：适用的硬件平台。包括 <code>x86_64</code>、<code>i686</code> 等，<code>noarch</code> 表示能安装在任何平台。</li>
</ul>
<p>举例：</p>
<blockquote>
<p>nginx-1.16.1-1.el7.x86_64.rpm</p>
</blockquote>
<h3 id="rpm-命令"><a href="#rpm-命令" class="headerlink" title="rpm 命令"></a>rpm 命令</h3><p>安装管理 RPM 包需要用到 <code>rpm</code> 命令，常用参数如下：</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>-q</code></td>
<td align="center">查询 rpm 包的信息</td>
</tr>
<tr>
<td align="center"><code>-i</code></td>
<td align="center">安装 rpm 包</td>
</tr>
<tr>
<td align="center"><code>-U</code></td>
<td align="center">升级 rpm 包</td>
</tr>
<tr>
<td align="center"><code>-e</code></td>
<td align="center">卸载 rpm 包</td>
</tr>
<tr>
<td align="center"><code>-h</code></td>
<td align="center">以 <code>#</code> 显示安装进度</td>
</tr>
<tr>
<td align="center"><code>-v</code></td>
<td align="center">显示安装详情</td>
</tr>
<tr>
<td align="center"><code>-l</code></td>
<td align="center">列出安装包中文件</td>
</tr>
<tr>
<td align="center"><code>-p</code></td>
<td align="center">对 rpm 包进行查询、与其他参数一起使用</td>
</tr>
</tbody></table>
<p>以上参数需要组合使用，举例：</p>
<p>查看安装包信息</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">rpm -qip nginx-1.16.1-1.el7.x86_64.rpm</span><br></pre></td></tr></tbody></table></figure>

<p>列出安装包中的文件</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">rpm -qlp nginx-1.16.1-1.el7.x86_64.rpm</span><br></pre></td></tr></tbody></table></figure>

<p>安装安装包</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">rpm -ivh nginx-1.16.1-1.el7.x86_64.rpm</span><br></pre></td></tr></tbody></table></figure>

<p>查询已安装所有安装包</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">rpm -qa</span><br></pre></td></tr></tbody></table></figure>

<p>卸载安装包</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">rpm -evh nginx-1.16.1-1.el7.x86_64 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 后面跟 rpm 包的全名</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>补充：</p>
<ul>
<li>使用 <code>--nodeps</code> 跳过依赖验证，强制操作。</li>
<li>rpm默认不允许重复安装和降级安装，可使用 <code>--force</code> 强制安装。</li>
<li>可使用 <code>-qf</code> 查看某个文件属于哪个rpm包。</li>
</ul>
</blockquote>
<h2 id="YUM"><a href="#YUM" class="headerlink" title="YUM"></a>YUM</h2><p>当一个 rpm 包的安装需要依赖其他包时，就必须先安装依赖包。YUM（Yellowdog Updater, Modified）工具基于 RPM ，可以从指定源空间（服务器、本地目录等）自动下载 rpm 包并处理依赖关系。</p>
<h3 id="yum-命令"><a href="#yum-命令" class="headerlink" title="yum 命令"></a>yum 命令</h3><p>安装指定软件 :</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yum -y install nginx # -y 表示互动时输入 yes</span><br></pre></td></tr></tbody></table></figure>

<p>列出系统中已安装软件</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yum list</span><br></pre></td></tr></tbody></table></figure>

<p>列出系统中可升级的所有软件</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yum check-update</span><br></pre></td></tr></tbody></table></figure>

<p>升级系统中可升级的所有软件</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yum update</span><br></pre></td></tr></tbody></table></figure>

<p>升级指定软件</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yum update nginx</span><br></pre></td></tr></tbody></table></figure>

<p>卸载指定软件</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yum remove nginx</span><br></pre></td></tr></tbody></table></figure>

<h3 id="repo-文件"><a href="#repo-文件" class="headerlink" title="repo 文件"></a>repo 文件</h3><p>yum 使用仓库保存管理 rpm 包，仓库的配置文件以 <code>.repo</code> 为扩展名，存放在 <code>/etc/yum.repo.d/</code> 目录下。一个配置文件中包含了一个或多个 yum 仓库的配置信息。</p>
<h3 id="rpm-包下载"><a href="#rpm-包下载" class="headerlink" title="rpm 包下载"></a>rpm 包下载</h3><h4 id="使用-downloadonly"><a href="#使用-downloadonly" class="headerlink" title="使用 --downloadonly"></a>使用 <code>--downloadonly</code></h4><p>没有命令需要先安装 <code>downloadonly</code> 插件：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yum install yum-plugin-downloadonly</span><br></pre></td></tr></tbody></table></figure>

<p>下载 rpm 包和依赖：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yum install --downloadonly --downloaddir=/home/rpm-share/yum nginx</span><br></pre></td></tr></tbody></table></figure>

<p>默认下载路径：<code>/var/cache/yum/x86_64/[centos/fedora-version]/[repository]/packages</code></p>
<p>已安装再次下载：<code>reinstall</code>，此时不会下载依赖。</p>
<h4 id="使用-yumdownloader"><a href="#使用-yumdownloader" class="headerlink" title="使用 yumdownloader"></a>使用 yumdownloader</h4><p>没有命令需要先安装：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yum install -y yum-utils</span><br></pre></td></tr></tbody></table></figure>

<p>下载 rpm 包和依赖：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yumdownloader --destdir=/home/rpm-share/yum --resolve nginx</span><br></pre></td></tr></tbody></table></figure>

<p><code>--destdir</code> 指定下载的软件包存放路径，不指定默认当前路径。<br><code>--resolve</code> 解决依赖关系并下载所需的包。</p>
<h2 id="rpm-包制作"><a href="#rpm-包制作" class="headerlink" title="rpm 包制作"></a>rpm 包制作</h2><h3 id="spec-基础"><a href="#spec-基础" class="headerlink" title="spec 基础"></a>spec 基础</h3><p>要制作 rpm 包，关键在于编写包的 spec 描述文件。</p>
<h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><ul>
<li><p><code>Name</code>：软件包的名字，后面可使用 <code>%{name}</code> 的方式引用</p>
</li>
<li><p><code>Version</code>：软件版本号，后面可使用 <code>%{version}</code> 引用</p>
</li>
<li><p><code>Release</code>：软件包释出号/发行号，后面可使用 <code>%{release}</code> 引用</p>
</li>
<li><p><code>Group</code>：软件分组，参见 <code>/usr/share/doc/rpm-4.x.x/GROUPS</code></p>
</li>
<li><p><code>License</code>：软件授权方式，通常是 GPL（自由软件）或 GPLv2，BSD</p>
</li>
<li><p><code>Summary</code>：软件包的内容概要</p>
</li>
<li><p><code>URL</code>：软件的主页</p>
</li>
<li><p><code>Packager</code>：打包者的信息</p>
</li>
<li><p><code>Vendor</code>：软件开发者的名字，发行商或打包组织的信息，例如 <code>Fedora Project</code></p>
</li>
<li><p><code>Source0</code>：源代码包的名称，可以带多个用 <code>Source1</code>、<code>Source2</code> 等源，后面也可以用 <code>%{source1}</code>、<code>%{source2}</code> 引用，如有补丁也写在此处，如：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">Source0: %{name}-%{version}.tar.gz</span><br><span class="line">Patch0: some-bugs0.patch                    </span><br><span class="line">Patch1: some-bugs1.patch                   </span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>BuildRequires</code>: 制作过程中用到的软件包，构建依赖</p>
</li>
<li><p><code>Requires</code>: 安装时所需软件包</p>
<ul>
<li><code>Requires(pre/post/preun/postun)</code>: 指定不同阶段的依赖</li>
</ul>
</li>
<li><p><code>BuildRoot</code>: 这个是安装或编译时使用的「虚拟目录」，打包时会用到该目录下文件，可查看安装后文件路径，例如：<code>BuildRoot: %_topdir/BUILDROOT</code>。</p>
</li>
<li><p><code>%description</code>：软件包详细说明</p>
</li>
</ul>
<h4 id="主体"><a href="#主体" class="headerlink" title="主体"></a>主体</h4><p>主体包括 %prep，%build，%install，%files，%clean 几个关键阶段。</p>
<h5 id="prep-阶段"><a href="#prep-阶段" class="headerlink" title="%prep 阶段"></a>%prep 阶段</h5><p>对源代码包进行解压和打补丁，如：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">%prep</span><br><span class="line">%setup -q    <span class="comment"># 将 %sourcedir 目录下的源代码解压到 %builddir 目录下</span></span><br><span class="line">%pathch -p1  <span class="comment"># 给源代码打上补丁 Patch0 ， -p1 是忽略 patch 的第一层目录</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="build-阶段"><a href="#build-阶段" class="headerlink" title="%build 阶段"></a>%build 阶段</h5><p>在 <code>%_builddir</code> 目录下执行源码包的编译。一般是执行执行常见的 <code>configure</code> 和 <code>make</code> 操作，如：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">%configure                                             <span class="comment"># 执行源代码的 configure 配置</span></span><br><span class="line">make %{?_smp_mflags} OPTIMIZE=<span class="string">"%{optflags}"</span>           <span class="comment"># 多核则并行编译</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="install-阶段"><a href="#install-阶段" class="headerlink" title="%install 阶段"></a>%install 阶段</h5><p>执行 <code>make install</code> 命令操作。开始把软件安装到虚拟的根目录中。这个阶段会在 <code>%buildrootdir</code> 目录里建好目录结构，然后将需要打包到 rpm 软件包里的文件从 <code>%builddir</code> 里拷贝到 <code>%_buildrootdir</code> 里对应的目录里。</p>
<p>在 <code>~/rpmbuild/BUILD/%{name}-%{version}</code> 目录中进行 <code>make install</code> 的操作。<code>%install</code> 很重要，因为如果这里的路径不对的话，则下面 <code>%file</code> 中寻找文件的时候就会失败。</p>
<blockquote>
<p>注意：<br><code>%install</code> 部分使用的是绝对路径，而 <code>%file</code> 部分使用则是相对路径。<br>当用户最终用 <code>rpm -ivh</code> 安装软件包时，这些文件会安装到用户系统中相应的目录里。</p>
</blockquote>
<p>如：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">%install</span><br><span class="line">rm -rf <span class="variable">$RPM_BUILD_ROOT</span>                         <span class="comment"># 清空下安装目录，实际会自动清除</span></span><br><span class="line">make install DESTDIR=<span class="variable">$RPM_BUILD_ROOT</span>         <span class="comment"># 安装到 buildroot 目录下         </span></span><br></pre></td></tr></tbody></table></figure>

<p><code>%install</code> 阶段还可以执行相关脚本</p>
<ul>
<li><code>%pre</code> 安装前执行的脚本</li>
<li><code>%post</code> 安装后执行的脚本</li>
<li><code>%preun</code> 卸载前执行的脚本</li>
<li><code>%postun</code> 卸载后执行的脚本</li>
</ul>
<blockquote>
<p>注意：<br><code>%preun</code> 在升级的时候会执行，<code>%postun</code> 在升级的时候不会执行。</p>
</blockquote>
<h5 id="file-阶段"><a href="#file-阶段" class="headerlink" title="%file 阶段"></a>%file 阶段</h5><p>说明会将 <code>%{buildroot}</code> 目录下的哪些文件和目录最终打包到rpm包里。</p>
<p>定义软件包所包含的文件，分为三类：</p>
<ul>
<li>说明文档（doc）</li>
<li>配置文件（config）</li>
<li>执行程序</li>
</ul>
<p>在 <code>%files</code> 阶段的第一条命令的语法是：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">%defattr(文件权限,用户名,组名,目录权限) </span><br></pre></td></tr></tbody></table></figure>

<p>还可定义文件存取权限，拥有者及组别。如：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">%files</span><br><span class="line">%defattr (-,root,root,0755)                     <span class="comment"># 设定默认权限</span></span><br><span class="line">%config(noreplace) /etc/my.cnf                  <span class="comment"># 表明是配置文件，noplace 表示替换文件</span></span><br><span class="line">%doc %{_mandir}/1.log                           <span class="comment"># 表明这个是文档</span></span><br><span class="line">%attr(755, root, root) %{_sbindir}/mysqld        <span class="comment"># 分别是权限，用户，用户组</span></span><br><span class="line">%exclude %{_mandir}/2.log                      <span class="comment"># 列出不想打包到 rpm 中的文件</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意：</p>
<ul>
<li><code>%files</code> 里的文件同时需要在 <code>%install</code> 中安装。</li>
<li><code>%{buildroot}</code> 里的所有文件都要明确被指定是否要被打包到 rpm 里。</li>
<li>如果声明了 <code>%{buildroot}</code> 里不存在的文件或者目录也会报错。</li>
<li><code>%exclude</code> 指定的文件如果不存在会报错。</li>
</ul>
</blockquote>
<h5 id="clean-阶段"><a href="#clean-阶段" class="headerlink" title="%clean 阶段"></a>%clean 阶段</h5><p>编译完成后一些清理工作，主要包括对 <code>%{buildroot}</code> 目录的清空（非必须），如：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">make clean</span><br></pre></td></tr></tbody></table></figure>

<h5 id="changelog-阶段"><a href="#changelog-阶段" class="headerlink" title="%changelog 阶段"></a>%changelog 阶段</h5><p>主要记录的每次打包时的修改变更日志。标准格式是：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">* date +<span class="string">"%a %b %d %Y"</span> 修改人 邮箱 本次版本 x.y.z-p </span><br><span class="line">- 本次变更修改了那些内容</span><br></pre></td></tr></tbody></table></figure>

<h4 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h4><h5 id="内建宏"><a href="#内建宏" class="headerlink" title="内建宏"></a>内建宏</h5><p>spec 文件中在定义文件的安装路径时通常会使用 RPM 内建的宏定义，可以在 <code>/usr/lib/rpm/macros</code> 找到，附录一些常见的宏：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">%{_sysconfdir}        /etc</span><br><span class="line">%{_prefix}            /usr</span><br><span class="line">%{_exec_prefix}       %{_prefix}</span><br><span class="line">%{_bindir}            %{_exec_prefix}/bin</span><br><span class="line">%{_lib}               lib (lib64 on 64bit systems)</span><br><span class="line">%{_libdir}            %{_exec_prefix}/%{_lib}</span><br><span class="line">%{_libexecdir}        %{_exec_prefix}/libexec</span><br><span class="line">%{_sbindir}           %{_exec_prefix}/sbin</span><br><span class="line">%{_sharedstatedir}    /var/lib</span><br><span class="line">%{_datadir}           %{_prefix}/share</span><br><span class="line">%{_includedir}        %{_prefix}/include</span><br><span class="line">%{_oldincludedir}     /usr/include</span><br><span class="line">%{_infodir}           /usr/share/info</span><br><span class="line">%{_mandir}            /usr/share/man</span><br><span class="line">%{_localstatedir}     /var</span><br><span class="line">%{_initddir}          %{_sysconfdir}/rc.d/init.d </span><br><span class="line">%{_topdir}            %{getenv:HOME}/rpmbuild</span><br><span class="line">%{_builddir}          %{_topdir}/BUILD</span><br><span class="line">%{_rpmdir}            %{_topdir}/RPMS</span><br><span class="line">%{_sourcedir}         %{_topdir}/SOURCES</span><br><span class="line">%{_specdir}           %{_topdir}/SPECS</span><br><span class="line">%{_srcrpmdir}         %{_topdir}/SRPMS</span><br><span class="line">%{_buildrootdir}      %{_topdir}/BUILDROOT</span><br><span class="line">%{_var}               /var</span><br><span class="line">%{_tmppath}           %{_var}/tmp</span><br><span class="line">%{_usr}               /usr</span><br><span class="line">%{_usrsrc}            %{_usr}/src</span><br><span class="line">%{_docdir}            %{_datadir}/doc</span><br><span class="line">%{buildroot}          %{_buildrootdir}/%{name}-%{version}-%{release}.%{_arch}</span><br><span class="line">$RPM_BUILD_ROOT       %{buildroot}</span><br></pre></td></tr></tbody></table></figure>

<p>通过命令 <code>rpm --eval "%{宏名称}"</code> 来查看具体对应路径，如：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">rpm --<span class="built_in">eval</span> <span class="string">"%{_topdir}"</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="自定义宏"><a href="#自定义宏" class="headerlink" title="自定义宏"></a>自定义宏</h5><p>使用 <code>%define</code> 可自定义宏变量。</p>
<blockquote>
<p>注意：<br>打包时会对所有安装的文件进行 <code>strip</code> 操作，去除调试信息等。<code>strip</code> 操作定义在宏 <code>__os_install_post</code> 中，可通过 <code>rpmbuild --showrc</code> 查看，将其设为 <code>%{nil}</code> 可跳过 <code>strip</code> 操作。即：<code>%define __os_install_post %{nil}</code></p>
</blockquote>
<h3 id="rpmbuild-打包"><a href="#rpmbuild-打包" class="headerlink" title="rpmbuild 打包"></a>rpmbuild 打包</h3><p>使用 <code>rpmbuild</code> 制作rpm包，<code>rpmbuid</code> 的默认工作路径是 <code>$HOME/rpmbuild</code>，并且推荐用户在制作 rpm 软件包时尽量不要以 root 身份进行操作。</p>
<h4 id="打包目录"><a href="#打包目录" class="headerlink" title="打包目录"></a>打包目录</h4><p>构建打包目录，一般在 <code>~/rpmbuild</code> 目录下建立以下目录：</p>
<ul>
<li><code>SPEC</code></li>
<li><code>SOURCE</code> </li>
<li><code>BUILD</code></li>
<li><code>RPM</code></li>
<li><code>SRPM</code></li>
<li><code>BUILDROOT</code></li>
</ul>
<p>对应关系：</p>
<table>
<thead>
<tr>
<th>默认位置</th>
<th>宏</th>
<th>名称</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>~/rpmbuild/SPECS</td>
<td>%_specdir</td>
<td>spec 文件目录</td>
<td>保存 RPM 包配置（.spec）文件</td>
</tr>
<tr>
<td>~/rpmbuild/SOURCES</td>
<td>%_sourcedir</td>
<td>源代码目录</td>
<td>保存源码包（如 .tar 包）和所有 patch 补丁</td>
</tr>
<tr>
<td>~/rpmbuild/BUILD</td>
<td>%_builddir</td>
<td>构建目录</td>
<td>源码包被解压至此，并在该目录的子目录完成编译</td>
</tr>
<tr>
<td>~/rpmbuild/RPMS</td>
<td>%_rpmdir</td>
<td>标准 RPM 包目录</td>
<td>生成/保存二进制 RPM 包</td>
</tr>
<tr>
<td>~/rpmbuild/SRPMS</td>
<td>%_srcrpmdir</td>
<td>源代码 RPM 包目录</td>
<td>生成/保存源码 RPM 包（SRPM）</td>
</tr>
<tr>
<td>~/rpmbuild/BUILDROOT</td>
<td>%_buildrootdir</td>
<td>最终安装目录</td>
<td>保存 <code>%install</code> 阶段安装的文件</td>
</tr>
</tbody></table>
<h4 id="打包命令"><a href="#打包命令" class="headerlink" title="打包命令"></a>打包命令</h4><p>切换到 <code>rpmbuild/SPECS</code> 目录下执行打包编译命令，如：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">rpmbuild -ba 软件名-版本.spec </span><br></pre></td></tr></tbody></table></figure>

<p><code>rpmbuild</code>命令参数：</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>-bp</code></td>
<td align="center">只解压源码及应用补丁</td>
</tr>
<tr>
<td align="center"><code>-bc</code></td>
<td align="center">只进行编译</td>
</tr>
<tr>
<td align="center"><code>-bi</code></td>
<td align="center">只进行安装到 <code>%{buildroot}</code></td>
</tr>
<tr>
<td align="center"><code>-bb</code></td>
<td align="center">只生成二进制 rpm 包</td>
</tr>
<tr>
<td align="center"><code>-bs</code></td>
<td align="center">只生成源码 rpm 包</td>
</tr>
<tr>
<td align="center"><code>-ba</code></td>
<td align="center">生成二进制 rpm 包和源码 rpm 包</td>
</tr>
<tr>
<td align="center"><code>--target</code></td>
<td align="center">指定生成 rpm 包的平台</td>
</tr>
</tbody></table>
<h4 id="修改默认工作路径"><a href="#修改默认工作路径" class="headerlink" title="修改默认工作路径"></a>修改默认工作路径</h4><p><code>rpmbuild</code> 默认工作路径通常由 <code>%_topdir</code> 的宏变量来定义。如果想更改有以下方法：</p>
<h5 id="修改-rpmmacros-的隐藏文件"><a href="#修改-rpmmacros-的隐藏文件" class="headerlink" title="修改 .rpmmacros 的隐藏文件"></a>修改 <code>.rpmmacros</code> 的隐藏文件</h5><p>在 <code>root</code> 下建立一个名为 <code>.rpmmacros</code> 的隐藏文件，然后在里面重新定义 <code>%_topdir</code>，指向一个新的目录名。<code>.rpmmacros</code> 文件内容如下：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">%_topdir %(<span class="built_in">echo</span> <span class="variable">$HOME</span>)/rpmbuild</span><br><span class="line"></span><br><span class="line">%_smp_mflags %( \</span><br><span class="line">    [ -z <span class="string">"<span class="variable">$RPM_BUILD_NCPUS</span>"</span> ] \\\</span><br><span class="line">        &amp;&amp; RPM_BUILD_NCPUS=<span class="string">"`/usr/bin/nproc 2&gt;/dev/null || \\\</span></span><br><span class="line"><span class="string">                             /usr/bin/getconf _NPROCESSORS_ONLN`"</span>; \\\</span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$RPM_BUILD_NCPUS</span>"</span> -gt 16 ]; <span class="keyword">then</span> \\\</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"-j16"</span>; \\\</span><br><span class="line">    <span class="keyword">elif</span> [ <span class="string">"<span class="variable">$RPM_BUILD_NCPUS</span>"</span> -gt 3 ]; <span class="keyword">then</span> \\\</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"-j<span class="variable">$RPM_BUILD_NCPUS</span>"</span>; \\\</span><br><span class="line">    <span class="keyword">else</span> \\\</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"-j3"</span>; \\\</span><br><span class="line">    <span class="keyword">fi</span> )</span><br><span class="line">    </span><br><span class="line">%__arch_install_post \</span><br><span class="line">    [ <span class="string">"%{buildarch}"</span> = <span class="string">"noarch"</span> ] || QA_CHECK_RPATHS=1 ; \</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"<span class="variable">${QA_CHECK_RPATHS:-}</span>"</span> <span class="keyword">in</span> [1yY]*) /usr/lib/rpm/check-rpaths ;; <span class="keyword">esac</span> \</span><br><span class="line">    /usr/lib/rpm/check-buildroot</span><br></pre></td></tr></tbody></table></figure>

<h5 id="使用-rpmbuild-命令时定义"><a href="#使用-rpmbuild-命令时定义" class="headerlink" title="使用 rpmbuild 命令时定义"></a>使用 <code>rpmbuild</code> 命令时定义</h5><p>使用 <code>rpmbuild</code> 时覆盖 <code>%_topdir</code> 的宏变量定义来指定此次打包的工作路径：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">rpmbuild --define <span class="string">"_topdir <span class="variable">${dir:-新的目录}</span>"</span> -ba 软件名-版本.spec </span><br></pre></td></tr></tbody></table></figure>

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>RPM</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/4a17b156/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>设计模式中的设计原则</title>
    <url>/posts/826d12e5/</url>
    <content><![CDATA[<h2 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h2><ul>
<li>抽象</li>
<li>封装</li>
<li>继承</li>
<li>多态</li>
</ul>
<h2 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h2><blockquote>
<p><a href="http://c.biancheng.net/design_pattern/">设计模式（Design Pattern）</a>是前辈们对代码开发经验的总结，是解决特定问题的一系列套路。它不是语法规定，而是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案。</p>
<p>1995 年，GoF（Gang of Four，四人组/四人帮）合作出版了《设计模式：可复用面向对象软件的基础》一书，共收录了 23 种设计模式，从此树立了软件设计模式领域的里程碑，人称「GoF设计模式」。</p>
</blockquote>
<h2 id="为什么学习设计模式"><a href="#为什么学习设计模式" class="headerlink" title="为什么学习设计模式"></a>为什么学习设计模式</h2><ul>
<li><p>设计模式是经过实践验证的解决方案，能指导你如何使用面向对象的设计原则来解决各种问题。 </p>
</li>
<li><p>设计模式是高效沟通的通用语言。你只需说“这里用单例就可以了”，所有人都会理解这条建议背后的想法。只要知晓模式及其名称，你就无需解释什么是单例。</p>
</li>
<li><p>…</p>
</li>
</ul>
<h2 id="优秀设计的特征"><a href="#优秀设计的特征" class="headerlink" title="优秀设计的特征"></a>优秀设计的特征</h2><ul>
<li><p><strong>代码复用</strong></p>
<p>减少开发成本的最常用的方式之一。</p>
</li>
<li><p><strong>扩展性</strong></p>
<p>理解更深入之后重构代码；程序经常需要变化适应新需求。</p>
</li>
</ul>
<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><h3 id="封装变化的内容"><a href="#封装变化的内容" class="headerlink" title="封装变化的内容"></a>封装变化的内容</h3><p>找到程序中的变化内容并将其与不变的内容区分开，将变更的影响最小化。</p>
<h4 id="方法层面的封装"><a href="#方法层面的封装" class="headerlink" title="方法层面的封装"></a>方法层面的封装</h4><p>例如，有一个获取订单总价的方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">method <span class="title">getOrderTotal</span><span class="params">(order)</span></span></span><br><span class="line"><span class="function">    total </span>= <span class="number">0</span></span><br><span class="line">    foreach item in order.lineItems</span><br><span class="line">        total += item.price * item.quantity</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (order.country == <span class="string">"US"</span>)</span><br><span class="line">         <span class="comment">// 美国增值税</span></span><br><span class="line">        total += total * <span class="number">0.07</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (order.country == <span class="string">"EU"</span>)</span><br><span class="line">        <span class="comment">// 欧洲增值税</span></span><br><span class="line">        total += total * <span class="number">0.20</span></span><br><span class="line">    <span class="keyword">return</span> total</span><br></pre></td></tr></tbody></table></figure>

<p><strong>修改前：</strong>税率计算代码和方法的其他代码混杂在一起。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">method <span class="title">getOrderTotal</span><span class="params">(order)</span></span></span><br><span class="line"><span class="function">    total </span>= <span class="number">0</span></span><br><span class="line">    foreach item in order.lineItems</span><br><span class="line">        total += item.price * item.quantity</span><br><span class="line"></span><br><span class="line">    total += total * getTaxRate(order.country)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"><span class="function">method <span class="title">getTaxRate</span><span class="params">(country)</span></span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(country == <span class="string">"US"</span>)</span></span></span><br><span class="line"><span class="function">        <span class="comment">// 美国增值税</span></span></span><br><span class="line"><span class="function">        return 0.07 </span></span><br><span class="line"><span class="function">    <span class="keyword">else</span> <span class="title">if</span> <span class="params">(country == <span class="string">"EU"</span>)</span></span></span><br><span class="line"><span class="function">        <span class="comment">// 欧洲增值税</span></span></span><br><span class="line"><span class="function">        return 0.20 </span></span><br><span class="line"><span class="function">    <span class="keyword">else</span></span></span><br><span class="line"><span class="function">        return 0</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>修改后：</strong>可通过调用指定方法获取税率。</p>
<h4 id="类层面的封装"><a href="#类层面的封装" class="headerlink" title="类层面的封装"></a>类层面的封装</h4><p>如果方法中的职责越来越多，还有其他变量引入，则可以将这些东西抽取到一个新类中。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/image-20210127212601157.png"></p>
<p><strong>修改前：</strong>在 订单 Order 类中计算税金。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/image-20210127212653972.png"></p>
<p><strong>修改后：</strong>对订单类隐藏税金计算。</p>
<h3 id="面向接口开发，而不是面向实现"><a href="#面向接口开发，而不是面向实现" class="headerlink" title="面向接口开发，而不是面向实现"></a>面向接口开发，而不是面向实现</h3><p>面向接口进行开发，而不是面向实现；依赖于抽象类型，而不是具体类。</p>
<p>例如，<code>Company</code> 类中有一个开发软件方法：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/image-20210127213442466.png"></p>
<p><strong>修改前：</strong>所有类都紧密耦合。</p>
<p>归纳雇员的方法并抽取通用接口：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/image-20210127235721308.png"></p>
<p><strong>优化：</strong>多态机制能帮助我们简化代码，但 <code>Company</code> 类的其他部分仍然依赖于具体的雇员类。</p>
<p>再抽象一个该方法来获取雇员：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/image-20210127213849586.png"></p>
<p><strong>修改后：</strong> <code>Company</code> 类的主要方法独立于具体的雇员类。雇员对象将在具体公司子类中创建。（工厂方法模式）</p>
<h3 id="组合优于继承"><a href="#组合优于继承" class="headerlink" title="组合优于继承"></a>组合优于继承</h3><p>继承可能是类之间最明显、最简单的代码复用方式。</p>
<p>继承存在的问题：</p>
<ul>
<li>子类不能减少父类的接口。（必须实现父类所有抽象方法）</li>
<li>重写方法时需要保证与父类版本兼容。（子类对象可能传递给父类作为参数的方法）</li>
<li>继承打破了父类的封装。（子类可以访问父类内部详细内容）</li>
<li>子类与父类紧密耦合。（父类修改可能破坏子类功能）</li>
<li>通过继承复用代码可能导致平行继承体系的产生。（多维度继承）</li>
</ul>
<p>例如，有一个创建车的程序，需要创建卡车和小汽车，有电车和油车之分，还有自动驾驶和手动驾驶之分：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/image-20210127214814494.png"></p>
<p><strong>继承：</strong>在多个维度上扩展一个类（汽车类型 × 引擎类型 × 驾驶类型）可能会导致子类组合的数量爆炸。</p>
<p>使用组合，将汽车行为委派给别的对象：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/image-20210127215038889.png"></p>
<p><strong>组合：</strong>将不同“维度”的功能抽取到各自的类层次结构中。（策略模式）</p>
<h3 id="SOLID-原则"><a href="#SOLID-原则" class="headerlink" title="SOLID 原则"></a>SOLID 原则</h3><p>Robert C. Martin《敏捷软件开发：原则、模式与实践》中首次提出。SOLID 是让软件设计更易于理解、更加灵活和更易于维护的五个原则的简称。</p>
<h4 id="单一职责原则-Single-Responsibility-Principle"><a href="#单一职责原则-Single-Responsibility-Principle" class="headerlink" title="单一职责原则(Single Responsibility Principle)"></a>单一职责原则(Single Responsibility Principle)</h4><p>修改类的原因只能有一个。该原则的目的是减少复杂度，尽量让每个类只负责软件中的一个功能，并将该功能完全封装（隐藏）在该类中。</p>
<p>例如，有一个雇员类：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/image-20210127215722067.png"></p>
<p><strong>修改前：</strong>类中包含多个不同的行为。</p>
<p>将与打印时间表报告相关的行为移动到一个单独的类中，这样其他与报告相关的内容也可以移到这个类中。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/image-20210127215854115.png"></p>
<p><strong>修改后：</strong>额外行为有了它们自己的类。</p>
<h4 id="开闭原则-Open-closed-Principle"><a href="#开闭原则-Open-closed-Principle" class="headerlink" title="开闭原则(Open/closed Principle)"></a>开闭原则(Open/closed Principle)</h4><p>对于扩展，类应该是“开放”的；对于修改，类则应是“封闭”的。该原则主要理念是实现新功能时保持已有代码不变。</p>
<p>例如，有一个计算运输费用的 <code>Order</code> 类，该类中所有运输方法都以硬编码的方式实现。如果你需要添加一个新的运输方式，那就必须承担可能对 <code>Order</code> 类造成破坏的风险来对其进行修改。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/image-20210127235833617.png"></p>
<p><strong>修改前：</strong>在程序中添加新的运输方式时，你必须对 <code>Order</code> 类进行修改。</p>
<p>使用策略模式进行修改，将运输方法抽取出来：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/image-20210127235902200.png"></p>
<p><strong>修改后：</strong>添加新的运输方式不需要修改已有的类，并且满足单一职责原则。</p>
<h4 id="里氏替换原则-Liskov-Substitution-Principle"><a href="#里氏替换原则-Liskov-Substitution-Principle" class="headerlink" title="里氏替换原则(Liskov Substitution Principle)"></a>里氏替换原则(Liskov Substitution Principle)</h4><p>当你扩展一个类时， 要能在不修改客户端（使用这个类的地方）代码的情况下将子类的对象作为父类对象进行传递。</p>
<p>该原则对子类的具体要求：</p>
<ul>
<li><p>子类方法的参数类型必须与其父类的参数类型相匹配或更加抽象。</p>
<p>父类有方法 <code>feed(Cat c)</code>，子类重写 <code>feed(Animal c)</code> :heavy_check_mark: <code>feed(BlackCat c)</code> <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8">❌</span></p>
</li>
<li><p>子类方法的返回值类型必须与父类方法的返回值类型或是其子类相匹配。</p>
<p>父类有方法 <code>Cat buyCat()</code>，子类重写 <code>BlackCat buyCat()</code> :heavy_check_mark: <code>Animal buyCat()</code> <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8">❌</span></p>
</li>
<li><p>子类中的方法不应抛出基础方法预期之外的异常类型。</p>
</li>
<li><p>子类不应该加强其前置条件。</p>
<p>父类方法参数为 <code>int</code>，子类方法参数为 <code>正数</code><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8">❌</span></p>
</li>
<li><p>子类不能削弱其后置条件。</p>
<p>父类方法使用数据库连接并关闭，子类方法不关闭连接<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8">❌</span></p>
</li>
<li><p>父类的不变量必须保留。</p>
</li>
<li><p>子类不能修改超类中私有成员变量的值。</p>
</li>
</ul>
<p>例如，有一个文档类：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/image-20210128002500134.png"></p>
<p><strong>修改前：</strong>只读文件中的保存行为没有任何意义，因此子类试图在重写后的方法中重置父类行为来解决这个问题。</p>
<p>只读文件子类（<code>ReadOnlyDocument</code>）中的 <code>save</code> 方法会在被调用时抛出一个异常，而父类方法则没有这个限制。如果在保存前没有检查文档类型，客户端代码将会出错。</p>
<p>重新设计类层次结构，子类应该扩展超类的行为：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/image-20210128003300671.png"></p>
<p><strong>修改后：</strong>当把只读文档类作为层次结构中的基类后，这个问题得到了解决。只读文档变成了层次结构中的基类。可写文件现在变成了子类，对基类进行扩展并添加了保存行为。</p>
<h4 id="接口隔离原则-Interface-Segregation-Principle"><a href="#接口隔离原则-Interface-Segregation-Principle" class="headerlink" title="接口隔离原则(Interface Segregation Principle)"></a>接口隔离原则(Interface Segregation Principle)</h4><p>客户端不应被强迫依赖于其不使用的方法。尽量缩小接口的范围，使得客户端的类不必实现其不需要的行为。</p>
<p>例如，有一程序库可以和云服务供应商整合：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/image-20210128000002165.png"></p>
<p><strong>修改前：</strong>不是所有客户端能满足复杂接口的要求。</p>
<p>将接口拆分为多个部分：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/image-20210128000032581.png"></p>
<p><strong>修改后：</strong>一个复杂的接口被拆分为一组颗粒度更小的接口。</p>
<p>不要进一步划分已经非常具体的接口。创建的接口越多，代码就越复杂。</p>
<h4 id="依赖倒置原则-Dependency-Inversion-Principle"><a href="#依赖倒置原则-Dependency-Inversion-Principle" class="headerlink" title="依赖倒置原则(Dependency Inversion Principle)"></a>依赖倒置原则(Dependency Inversion Principle)</h4><p>高层次的类不应该依赖于低层次的类。两者都应该依赖于抽象接口。抽象接口不应依赖于具体实现。具体实现应该依赖于抽象接口。</p>
<p>通常在设计软件时，有不同层次的类：</p>
<ul>
<li><strong>低层次的类</strong>实现基础操作（例如磁盘操作、传输网络数据和连接数据库等）。</li>
<li><strong>高层次的类</strong>包含复杂业务逻辑以指导低层次的类执行特定操作。</li>
</ul>
<p>有时会先设计低层次的类， 然后才会开发高层次的类。 当低层次的东西还没有实现或不确定，就无法确定高层次类能实现哪些功能。</p>
<p>依赖倒置原则建议改变这种依赖方式。</p>
<p>例如，高层次的预算报告类使用低层次的数据库类来读取和保存其数据。低层次类中的任何改变（例如当数据库服务器发布新版本时）都可能会影响到高层次的类，但高层次的类不应关注数据存储的细节。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/image-20210128000142672.png"></p>
<p><strong>修改前：</strong>高层次的类依赖于低层次的类。</p>
<p>创建一个描述读写操作的高层接口， 并让报告类使用该接口代替低层次的类。然后可以修改或扩展低层次的原始类来实现业务逻辑声明的读写接口。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/LiLittleCat/PicBed/images/blog/image-20210128001951493.png"></p>
<p><strong>修改后：</strong>低层次的类依赖于高层次的抽象，原始的依赖关系被倒置。</p>
<p>有原则是件好事，但是应用这些原则可能会使程序架构变得过于复杂，要从实用的角度来考量，不能盲目遵守这些原则。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
